<!doctype html><html lang=en><head><meta charset=utf-8><title>Workshop Recap: Linkerd Certificate Management with Vault | Linkerd</title>
<link rel="shortcut icon" href=/favicon.png><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This blog post is based on a workshop that I delivered way back in September
2023(!) at Buoyant’s
Service Mesh Academy. If this seems
interesting, check out the
full recording!
Linkerd Certificate Management with Vault
Linkerd&rsquo;s ability to automatically secure communications using mTLS has always
been one of its headline features. Of course, mTLS requires certificates, and
managing certificates can be very tricky: you need to generate them, rotate
them, and distribute them to all the places that need them&mldr; while still being
careful to avoid exposing any private keys."><meta property="og:url" content="https://travisbeckham.github.io/2024/02/06/linkerd-certificates-with-vault/"><meta property="og:site_name" content="Linkerd"><meta property="og:title" content="Workshop Recap: Linkerd Certificate Management with Vault"><meta property="og:description" content="This blog post is based on a workshop that I delivered way back in September 2023(!) at Buoyant’s Service Mesh Academy. If this seems interesting, check out the full recording!
Linkerd Certificate Management with Vault Linkerd’s ability to automatically secure communications using mTLS has always been one of its headline features. Of course, mTLS requires certificates, and managing certificates can be very tricky: you need to generate them, rotate them, and distribute them to all the places that need them… while still being careful to avoid exposing any private keys."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-02-06T00:00:00+00:00"><meta property="article:modified_time" content="2024-02-06T00:00:00+00:00"><meta property="og:image" content="https://travisbeckham.github.io/2024/02/06/linkerd-certificates-with-vault/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://travisbeckham.github.io/2024/02/06/linkerd-certificates-with-vault/cover.jpg"><meta name=twitter:title content="Workshop Recap: Linkerd Certificate Management with Vault"><meta name=twitter:description content="This blog post is based on a workshop that I delivered way back in September 2023(!) at Buoyant’s Service Mesh Academy. If this seems interesting, check out the full recording!
Linkerd Certificate Management with Vault Linkerd’s ability to automatically secure communications using mTLS has always been one of its headline features. Of course, mTLS requires certificates, and managing certificates can be very tricky: you need to generate them, rotate them, and distribute them to all the places that need them… while still being careful to avoid exposing any private keys."><meta name=twitter:site content="@Linkerd"><link rel=canonical href=https://travisbeckham.github.io/2024/02/06/linkerd-certificates-with-vault/><link rel=stylesheet href=/css/main.css><script src=/js/main.js></script><script async defer src=https://buttons.github.io/buttons.js></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","author":"Flynn","datePublished":"2024-02-06T00:00:00Z","dateModified":"2024-02-06T00:00:00Z","headline":"Workshop Recap: Linkerd Certificate Management with Vault","image":"https://travisbeckham.github.io/2024/02/06/linkerd-certificates-with-vault/cover.jpg","publisher":{"@type":"Organization","name":"linkerd.io","logo":{"@type":"ImageObject","url":"https://travisbeckham.github.io/logos/linkerd.png","width":472,"height":100}}}</script></head><body><header class=main-header><div class=main-header__container><div class=main-header__logo><a href=/><img src=/logos/linkerd.png alt=Linkerd></a></div><input class=main-header__toggle-checkbox type=checkbox id=main-header-toggle>
<label class=main-header__toggle for=main-header-toggle><span class=main-header__toggle-icon><span class=main-header__toggle-icon--open><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3 6H21V8H3V6m0 5H21v2H3V11m0 5H21v2H3V16z"/></svg>
</span><span class=main-header__toggle-icon--close><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg></span></span></label><div class=main-header__nav><nav class=main-nav><ul class=main-nav__menu><li><a href=/docs>Docs</a></li><li><a href=#>Community<svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M7.41 8.58 12 13.17l4.59-4.59L18 10l-6 6-6-6L7.41 8.58z"/></svg></a><ul><li><a href=/community/get-involved/>Get Involved</a></li><li><a href=/community/adopters/>Adopters</a></li><li><a href=/community/ambassadors/>Linkerd Ambassadors</a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener>Buoyant's Linkerd Forum</a></li></ul></li><li class=main-nav__menu--selected><a href=/blog/>Blog</a></li><li><a href=/faq/>FAQ</a></li><li><a href=/enterprise/>Enterprise</a></li></ul><div class=main-nav__search><form action=/search method=get><div class="search-input search-input--sm"><svg class="icon" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5.0 0116 9.5c0 1.61-.59 3.09-1.56 4.23L14.71 14H15.5l5 5L19 20.5l-5-5V14.71L13.73 14.44C12.59 15.41 11.11 16 9.5 16A6.5 6.5.0 013 9.5 6.5 6.5.0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
<input type=text name=q placeholder=Search></div></form></div><div class=main-nav__github><a class=github-button href=https://github.com/linkerd/linkerd2 data-icon=octicon-star data-size=large data-show-count=true aria-label="Star linkerd/linkerd2 on GitHub">Star</a></div><div class=main-nav__forum><a href=https://linkerd.buoyant.io class="button button--primary button--sm" target=_blank rel=noopener>Join Forum</a></div></nav></div></div></header><div class=main-announcement>Service Mesh 101: Get Service Mesh-Certified
<span class=main-announcement__link><a href=https://buoyant.io/courses/service-mesh-101 target=_blank rel=noopener>Enroll now</a></span></div><main class=main-content><div class="blog blog--single"><div class="blog__container container"><div class=blog-post><div class=blog-post__header><h1>Workshop Recap: Linkerd Certificate Management with Vault</h1><div class=blog-post-meta><div class=blog-post-meta__media><img src=/authors/flynn.png alt=Flynn class="img img--48 img--round"></div><div class=blog-post-meta__body><div class=blog-post-meta__name>Flynn</div><div class=blog-post-meta__date>Feb 6, 2024 • 15 min read</div></div></div></div><div class=blog-post__cover><img src=/2024/02/06/linkerd-certificates-with-vault/cover.jpg alt=Cover class="img img--fill img--rounded"></div><div class="blog-post__content prose"><p><em>This blog post is based on a workshop that I delivered way back in September
2023(!) at Buoyant’s
<a href=https://buoyant.io/service-mesh-academy target=_blank rel=noopener>Service Mesh Academy</a>. If this seems
interesting, check out the
<a href=https://buoyant.io/service-mesh-academy/linkerd-with-external-cas-using-vault target=_blank rel=noopener>full recording</a>!</em></p><h2 id=linkerd-certificate-management-with-vault>Linkerd Certificate Management with Vault</h2><p>Linkerd&rsquo;s ability to automatically secure communications using mTLS has always
been one of its headline features. Of course, mTLS requires certificates, and
managing certificates can be very tricky: you need to generate them, rotate
them, and distribute them to all the places that need them&mldr; while still being
careful to avoid exposing any private keys.</p><p>For many of the demos we do, we sidestep all this by letting <code>linkerd install</code>
silently generate the certificates we need, then ignoring them beyond that. This
is vaguely OK for a demo, but it&rsquo;s totally unacceptable for the real world. In
the real world:</p><ul><li><p>The secret key for Linkerd&rsquo;s trust anchor should never be stored on the
cluster at all.</p></li><li><p>However, you&rsquo;ll need access to the secret key to rotate the identity issuer
certificate, which should happen frequently.</p></li><li><p>Finally, your organization may require that the trust anchor certificate must
be issued by a corporate certifying authority (CA), rather than being some
self-signed monstrosity. (They might require that of the identity issuer
certificate too: in many situations, the corporate security folks don&rsquo;t like
delegating issuing authority, for various reasons.)</p></li></ul><p>Ultimately, the way to tackle all of these issues is to use an <em>external CA</em> to
issue at least the trust anchor certificate. There are several ways to set that
up: in this article, we&rsquo;ll walk through a fairly real-world scenario:</p><ul><li><p>We&rsquo;ll install Linkerd without generating any certificates by hand, and without
having Linkerd generate the certificates itself;</p></li><li><p>We&rsquo;ll have Vault running <em>outside</em> the cluster to store keys and generate
certificates; and</p></li><li><p>We&rsquo;ll have cert-manager running <em>inside</em> the cluster to get the things Linkerd
needs from Vault, and store them where Linkerd needs to find them.</p></li></ul><p>Note that our goal is <strong>not</strong> to teach you how to use Vault, in particular: it&rsquo;s
to show a practical, relatively low-effort way to actually use external PKI with
Linkerd to bootstrap a zero-trust environment in Kubernetes. Many companies have
existing external PKI already set up (whether with Vault or something else);
being able to make use of it without too much work is a huge win</p><h2 id=the-setup>The Setup</h2><p>In order to demo all this simply, we&rsquo;ll be running Kubernetes in a <code>k3d</code>
cluster. We&rsquo;ll run Vault in Docker to make things easy to demo, but we will
<em>not</em> be running Docker in Kubernetes: Vault will run as a separate Docker
container that happens to be connected to the same Docker network as our <code>k3d</code>
cluster.</p><p>The big win of this setup is that you can run it completely on a laptop with no
external dependencies. If you want to replicate this with a cluster in the
cloud, that&rsquo;s no problem: just figure out a reasonable place outside the cluster
to run your Vault instance, and make sure that both your Kubernetes cluster and
your local machine have IP connectivity to your Vault instance. Everything else
should be pretty much the same.</p><p>The way all the pieces fit together here is more complex than normal:</p><ul><li><p>We&rsquo;ll start by creating our <code>k3d</code> cluster. This will be named <code>pki-cluster</code>,
and we&rsquo;ll tell <code>k3d</code> to connect it to a network named <code>pki-network</code>.</p></li><li><p>We&rsquo;ll then fire up Vault in a Docker container that&rsquo;s also connected to
<code>pki-network</code>. (And yes, we&rsquo;ll use Vault in dev mode to make life easier, but
that&rsquo;s the only way we&rsquo;ll cheat in this setup.)</p></li><li><p>We&rsquo;ll then use the <code>vault</code> CLI <em>running on our local machine</em> to configure
Vault in Docker.</p></li></ul><p>Taken together, this implies that we&rsquo;ll have to make sure that we can talk to
the Vault instance both from inside the Docker network and from our host
machine. This mirrors many real-world setups where your Kubernetes cluster is on
one network, but you do administration from a different network.</p><h3 id=tools-of-the-trade>Tools of the trade</h3><p>You&rsquo;ll need several CLI tools for this:</p><ul><li><code>linkerd</code>, from <code>https://linkerd.io/2.16/getting-started/</code>;</li><li><code>kubectl</code>, from <code>https://kubernetes.io/docs/tasks/tools/</code>;</li><li><code>helm</code>, from <code>https://helm.sh/docs/intro/quickstart/</code>;</li><li><code>jq</code>, from <code>https://jqlang.github.io/jq/download/</code>;</li><li><code>vault</code>, from <code>https://developer.hashicorp.com/vault/docs/install</code>; and</li><li><code>step</code>, from <code>https://smallstep.com/docs/step-cli/installation</code>.</li></ul><p>Of course you&rsquo;ll also need Docker. You can get that from
<code>https://docs.docker.com/engine/install/</code>, or you can try Colima from
<code>https://github.com/abiosoft/colima</code> instead.</p><h3 id=starting-our-k3d-cluster>Starting our <code>k3d</code> cluster</h3><p>Creating the <code>k3d</code> cluster looks horrible, but isn&rsquo;t that bad:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>k3d cluster create pki-cluster <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -p <span style=color:#a5d6ff>&#34;80:80@loadbalancer&#34;</span> -p <span style=color:#a5d6ff>&#34;443:443@loadbalancer&#34;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    --network<span style=color:#ff7b72;font-weight:700>=</span>pki-network <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    --k3s-arg <span style=color:#a5d6ff>&#39;--disable=local-storage,traefik,metrics-server@server:*;agents:*&#39;</span>
</span></span></code></pre></div><p>(If you already have a cluster named <code>pki-cluster</code>, you&rsquo;ll need to delete it, or
change the name above.)</p><p>This command looks complex, but it&rsquo;s actually less terrible than you might think
&ndash; most of it is just turning off things we don&rsquo;t need (traefik, local-storage,
and metrics-server), and we also expose ports 80 and 443 to our local system to
make it easy to try services out.</p><p>At this point, you should be able to run things like <code>kubectl get ns</code> or
<code>kubectl cluster-info</code> to verify that you can talk to your cluster. If not,
you&rsquo;ll need to figure out what&rsquo;s wrong and fix it.</p><h3 id=starting-vault>Starting Vault</h3><p>We have a running <code>k3d</code> cluster, so now let&rsquo;s get Vault going. This is another
complex-looking command:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       --detach <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       --rm --name vault <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       -p 8200:8200 <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       --network<span style=color:#ff7b72;font-weight:700>=</span>pki-network <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       --cap-add<span style=color:#ff7b72;font-weight:700>=</span>IPC_LOCK <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       hashicorp/vault <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       server <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       -dev -dev-listen-address 0.0.0.0:8200 <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>       -dev-root-token-id my-token
</span></span></code></pre></div><p>Breaking this down, we start with <code>docker run</code> since we want to start a
container running, and then provide a lot of parameters:</p><ul><li><p><code>--detach</code>: basically, run the container in the background;</p></li><li><p><code>--rm --name vault</code>: remove the container when it dies, and name it &ldquo;vault&rdquo; so
we can find it easily later;</p></li><li><p><code>-p 8200:8200</code>: expose Vault&rsquo;s API port to our local system;</p></li><li><p><code>--network=pki-network</code>: connect to the same network as our <code>k3d</code> cluster; and</p></li><li><p><code>--cap-add=IPC_LOCK</code>: give the container the <code>IPC_LOCK</code> capability, which
Vault needs.</p></li></ul><p>Next is the image name (<code>hashicorp/vault</code>), and then comes the command line for
Vault itself:</p><ul><li><p><code>server</code> is the (creatively named) command to run;</p></li><li><p><code>-dev</code>: run Vault in developer mode;</p></li><li><p><code>-dev-listen-address 0.0.0.0:8200</code>: bind on port 8200 on all interfaces rather
than just <code>localhost</code>; and</p></li><li><p><code>-dev-root-token-id my-token</code>: set the dev-mode root &ldquo;password&rdquo; to <code>my-token</code>,
which we will use to trivially log in later.</p></li></ul><p>Once you run that, you&rsquo;ll have Vault running in a Docker container, hooked up to
the same network as the <code>pki-cluster</code> we started a moment ago. (Again, if you
already have a container named <code>vault</code> you&rsquo;ll either need to kill it or change
the name above.)</p><p>Next up, we&rsquo;ll want to use the <code>vault</code> CLI on the local host to configure Vault.
We&rsquo;ll start by setting the <code>VAULT_ADDR</code> environment variable, so that we don&rsquo;t
have to include it in every command. Remember, we&rsquo;ll be running the <code>vault</code> CLI
on our local system, so we can just do this all using our local shell.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export <span style=color:#79c0ff>VAULT_ADDR</span><span style=color:#ff7b72;font-weight:700>=</span>http://0.0.0.0:8200/
</span></span></code></pre></div><p>At this point you should be able to run <code>vault status</code> to make sure that all is
well.</p><h3 id=setting-up-vault>Setting up Vault</h3><p>While this isn&rsquo;t a blog about how to operate Vault, we still need to configure
Vault to work the way Linkerd needs it to. We&rsquo;re not going to dive too deep into
the details here, but we&rsquo;ll talk a bit about it as we go.</p><p>First up, we&rsquo;ll authenticate our <code>vault</code> CLI to the Vault server, using the
<code>dev-root-token-id</code> that we passed to the server when we started it running.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault login my-token
</span></span></code></pre></div><p>Next up, we need to enable the Vault PKI engine, so that we can work with X.509
certificates at all, and configure its maximum allowed expiry time for
certificates. Here we&rsquo;re using 90 days (2160 hours).</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault secrets enable pki
</span></span><span style=display:flex><span>vault secrets tune -max-lease-ttl<span style=color:#ff7b72;font-weight:700>=</span>2160h pki
</span></span></code></pre></div><p>After that, we need to tell Vault to enable the URLs that cert-manager expects
to use when talking to Vault.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>vault write pki/config/urls <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>   <span style=color:#79c0ff>issuing_certificates</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;http://127.0.0.1:8200/v1/pki/ca&#34;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>   <span style=color:#79c0ff>crl_distribution_points</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;http://127.0.0.1:8200/v1/pki/crl&#34;</span>
</span></span></code></pre></div><p>Finally, cert-manager will need to present Vault with a token before Vault will
actually do things that cert-manager needs. Vault associates tokens with
<em>policies</em>, which are kind of like roles in other systems, so we&rsquo;ll start by
creating a policy that allows us to do anything&mldr;</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#a5d6ff>&lt;&lt;EOF | vault policy write pki_policy -
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>path &#34;pki*&#34; {
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    capabilities = [&#34;create&#34;, &#34;read&#34;, &#34;update&#34;, &#34;delete&#34;, &#34;list&#34;, &#34;sudo&#34;]
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>}
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>EOF</span>
</span></span></code></pre></div><p>&mldr;and then we&rsquo;ll get a token for that policy. Later, we&rsquo;ll feed this token to
cert-manager.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#79c0ff>VAULT_TOKEN</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#ff7b72>$(</span>vault write -field<span style=color:#ff7b72;font-weight:700>=</span>token /auth/token/create <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>                          <span style=color:#79c0ff>policies</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;pki_policy&#34;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>                          <span style=color:#79c0ff>no_parent</span><span style=color:#ff7b72;font-weight:700>=</span>true <span style=color:#79c0ff>no_default_policy</span><span style=color:#ff7b72;font-weight:700>=</span>true <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>                          <span style=color:#79c0ff>renewable</span><span style=color:#ff7b72;font-weight:700>=</span>true <span style=color:#79c0ff>ttl</span><span style=color:#ff7b72;font-weight:700>=</span>767h <span style=color:#79c0ff>num_uses</span><span style=color:#ff7b72;font-weight:700>=</span>0<span style=color:#ff7b72>)</span>
</span></span></code></pre></div><h2 id=creating-the-trust-anchor>Creating the Trust Anchor</h2><p>After all that, we can tell Vault to actually create our Linkerd trust anchor.
Note that:</p><ul><li><p>this certificate only exists within Vault;</p></li><li><p>we explicitly give it the common name of <code>root.linkerd.cluster.local</code>;</p></li><li><p>we set its TTL to our maximum of 2160 hours; and</p></li><li><p>we tell Vault to generate it using elliptic-curve crypto (<code>key_type=ec</code>).</p></li></ul><p>We tell <code>vault write</code> to only output the certificate, which we save so that we
can inspect it. Note that the certificate contains no private information, so
this is entirely safe.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#79c0ff>CERT</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#ff7b72>$(</span>vault write -field<span style=color:#ff7b72;font-weight:700>=</span>certificate pki/root/generate/internal <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>      <span style=color:#79c0ff>common_name</span><span style=color:#ff7b72;font-weight:700>=</span>root.linkerd.cluster.local <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>      <span style=color:#79c0ff>ttl</span><span style=color:#ff7b72;font-weight:700>=</span>2160h <span style=color:#79c0ff>key_type</span><span style=color:#ff7b72;font-weight:700>=</span>ec<span style=color:#ff7b72>)</span>
</span></span><span style=display:flex><span>echo <span style=color:#a5d6ff>&#34;</span><span style=color:#79c0ff>$CERT</span><span style=color:#a5d6ff>&#34;</span> | step certificate inspect -
</span></span></code></pre></div><p>You should see something like this:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Certificate:
</span></span><span style=display:flex><span>    Data:
</span></span><span style=display:flex><span>        Version: 3 (0x2)
</span></span><span style=display:flex><span>        Serial Number: 362108562520865298482690188008268341812601922978 (0x3f6d827011b333be6e509a3b13377282ed25a5a2)
</span></span><span style=display:flex><span>    Signature Algorithm: ECDSA-SHA256
</span></span><span style=display:flex><span>        Issuer: CN=root.linkerd.cluster.local
</span></span><span style=display:flex><span>        Validity
</span></span><span style=display:flex><span>            Not Before: Feb 7 23:09:21 2024 UTC
</span></span><span style=display:flex><span>            Not After : May 7 23:09:51 2024 UTC
</span></span><span style=display:flex><span>        Subject: CN=root.linkerd.cluster.local
</span></span><span style=display:flex><span>        Subject Public Key Info:
</span></span><span style=display:flex><span>            Public Key Algorithm: ECDSA
</span></span><span style=display:flex><span>                Public-Key: (256 bit)
</span></span><span style=display:flex><span>                X:
</span></span><span style=display:flex><span>                    1f:ae:48:c9:29:0f:ce:58:43:9d:9a:1a:ba:a9:71:
</span></span><span style=display:flex><span>                    4f:24:e3:31:fc:df:ae:da:ad:b9:04:b6:40:27:29:
</span></span><span style=display:flex><span>                    e8:3e
</span></span><span style=display:flex><span>                Y:
</span></span><span style=display:flex><span>                    f6:01:86:cf:54:57:b0:d7:84:ee:e5:7d:64:6b:28:
</span></span><span style=display:flex><span>                    21:99:7e:5a:bc:a3:92:17:01:51:0e:05:ba:69:97:
</span></span><span style=display:flex><span>                    4f:57
</span></span><span style=display:flex><span>                Curve: P-256
</span></span><span style=display:flex><span>        X509v3 extensions:
</span></span><span style=display:flex><span>            X509v3 Key Usage: critical
</span></span><span style=display:flex><span>                Certificate Sign, CRL Sign
</span></span><span style=display:flex><span>            X509v3 Basic Constraints: critical
</span></span><span style=display:flex><span>                CA:TRUE
</span></span><span style=display:flex><span>            X509v3 Subject Key Identifier:
</span></span><span style=display:flex><span>                84:9A:D1:67:5F:24:53:22:A2:1D:A5:8A:D9:B1:F9:C8:2D:3F:59:12
</span></span><span style=display:flex><span>            X509v3 Authority Key Identifier:
</span></span><span style=display:flex><span>                keyid:84:9A:D1:67:5F:24:53:22:A2:1D:A5:8A:D9:B1:F9:C8:2D:3F:59:12
</span></span><span style=display:flex><span>            Authority Information Access:
</span></span><span style=display:flex><span>                CA Issuers - URI:http://127.0.0.1:8200/v1/pki/ca
</span></span><span style=display:flex><span>            X509v3 Subject Alternative Name:
</span></span><span style=display:flex><span>                DNS:root.linkerd.cluster.local
</span></span><span style=display:flex><span>            X509v3 CRL Distribution Points:
</span></span><span style=display:flex><span>                Full Name:
</span></span><span style=display:flex><span>                  URI:http://127.0.0.1:8200/v1/pki/crl
</span></span><span style=display:flex><span>    Signature Algorithm: ECDSA-SHA256
</span></span><span style=display:flex><span>         30:44:02:20:46:35:54:a2:48:1e:56:04:7a:26:11:38:95:b3:
</span></span><span style=display:flex><span>         72:e7:b2:08:f8:62:a0:46:3a:cc:5c:dd:ff:66:99:26:4e:84:
</span></span><span style=display:flex><span>         02:20:22:2e:b8:78:7a:47:96:94:b7:db:cc:c7:57:22:d2:c2:
</span></span><span style=display:flex><span>         89:55:bf:42:5e:23:ee:2e:c1:a8:b9:cf:cf:c5:50:a0
</span></span></code></pre></div><p>Look specifically at the <code>Subject</code> and <code>Issuer</code>, which should both be
<code>CN=root.linkerd.cluster.local</code>. Likewise, the <code>X509v3 Subject Key Identifier</code>
and <code>X509v3 Authority Key Identifier</code> should have the same key ID.</p><p>That&rsquo;s actually all we need there! Now it&rsquo;s on to get cert-manager installed.</p><h2 id=installing-cert-manager>Installing cert-manager</h2><p>We&rsquo;ll start by using Helm to install both cert-manager and trust-manager.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm repo add --force-update jetstack https://charts.jetstack.io
</span></span><span style=display:flex><span>helm repo update
</span></span></code></pre></div><p>When we install cert-manager, we&rsquo;ll have it create the <code>cert-manager</code> namespace,
and install the cert-manager CRDs too.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install cert-manager jetstack/cert-manager <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>             -n cert-manager --create-namespace <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>             --set <span style=color:#79c0ff>installCRDs</span><span style=color:#ff7b72;font-weight:700>=</span>true --wait
</span></span></code></pre></div><p>trust-manager will be installed in the <code>cert-manager</code> namespace, but we&rsquo;ll
explicitly tell it to use the <code>linkerd</code> namespace as its &ldquo;trust namespace&rdquo;. The
trust namespace is the single namespace from which trust-manager is allowed to
read information, and we&rsquo;re going to need it to read the Linkerd identity
issuer.</p><p>We don&rsquo;t need to create the <code>cert-manager</code> namespace here (it already exists),
but we <em>do</em> need to create the <code>linkerd</code> namespace manually so that we can use
it as the trust namespace.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create namespace linkerd
</span></span><span style=display:flex><span>helm install trust-manager jetstack/trust-manager <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>             -n cert-manager <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>             --set app.trust.namespace<span style=color:#ff7b72;font-weight:700>=</span>linkerd <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>             --wait
</span></span></code></pre></div><p>At this point, if you run <code>kubectl get pods -n cert-manager</code>, you should see
both cert-manager and trust-manager running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>NAME                                      READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>cert-manager-cainjector-768dc45f6-6zkvn   1/1     Running   <span style=color:#a5d6ff>0</span>          47s
</span></span><span style=display:flex><span>cert-manager-845bf45b88-g94ls             1/1     Running   <span style=color:#a5d6ff>0</span>          47s
</span></span><span style=display:flex><span>cert-manager-webhook-7d9dddbf74-tkrht     1/1     Running   <span style=color:#a5d6ff>0</span>          47s
</span></span><span style=display:flex><span>trust-manager-76fc8cbb64-szwch            1/1     Running   <span style=color:#a5d6ff>0</span>          25s
</span></span></code></pre></div><h2 id=configuring-cert-manager-the-access-token-secret>Configuring cert-manager: the access-token secret</h2><p>OK, cert-manager is running! Next step, we need to configure it to produce the
certificates we need. This starts with saving the Vault token we got awhile back
for cert-manager to use.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create secret generic <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>               my-secret-token <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>               --namespace<span style=color:#ff7b72;font-weight:700>=</span>cert-manager <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>               --from-literal<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#79c0ff>token</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#34;</span><span style=color:#79c0ff>$VAULT_TOKEN</span><span style=color:#a5d6ff>&#34;</span>
</span></span></code></pre></div><p>We don&rsquo;t want to actually look into that secret, but we can describe it to make
sure that there&rsquo;s some data in it, at least.
<code>kubectl describe secret -n cert-manager my-secret-token</code> should show a key
called <code>token</code> with some data in it:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:         my-secret-token
</span></span><span style=display:flex><span>Namespace:    cert-manager
</span></span><span style=display:flex><span>Labels:       &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:  &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type:  Opaque
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>token:  95 bytes
</span></span></code></pre></div><h2 id=configuring-cert-manager-the-vault-issuer>Configuring cert-manager: the Vault issuer</h2><p>Recall that Linkerd needs two certificates:</p><ul><li>the <em>trust anchor</em> is the root of the heirarchy for Linkerd; and</li><li>the <em>identity issuer</em> is an intermediate CA cert that must be signed by the
trust anchor.</li></ul><p>We&rsquo;ve already told Vault to create the trust anchor for us: next up, we need to
configure cert-manager to create the identity issuer certificate. To do this,
cert-manager will produce a <em>certificate signing request</em> (CSR), which it will
then hand to Vault. Vault will use the CSR to produce a signed identity issuer
for cert-manager.</p><p>To make all this happen, we use a cert-manager ClusterIssuer resource to tell
cert-manager how to talk to Vault. This ClusterIssuer needs three critical bits
of information:</p><ol><li>The access token, which we just saved in a Secret.</li><li>The address of the Vault server.</li><li>The URL path to use to ask Vault for a new certificate. For Vault, this is
<code>pki/root/sign-intermediate</code>.</li></ol><p>So the address of the Vault server is the missing bit at the moment: we can&rsquo;t
use <code>0.0.0.0</code> as we&rsquo;ve been doing from our local host, because cert-manager
needs to talk to Vault from inside the Docker network. That means we need to
figure out the address of the <code>vault</code> container within that network.</p><p>Fortunately, that&rsquo;s not that hard: <code>docker inspect pki-network</code> will show us all
the details of everything attached to the <code>pki-network</code>, as JSON, so we can use
<code>jq</code> to extract the single bit that we need: the <code>IPv4Address</code> contained in the
block that also has a <code>Name</code> of <code>vault</code>:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#79c0ff>VAULT_DOCKER_ADDRESS</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#ff7b72>$(</span>
</span></span><span style=display:flex><span>  docker inspect pki-network <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>     | jq -r <span style=color:#a5d6ff>&#39;.[0].Containers | .[] | select(.Name == &#34;vault&#34;) | .IPv4Address&#39;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>     | cut -d/ -f1
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>)</span>
</span></span></code></pre></div><p>Given the right address for Vault, we can assemble the correct YAML:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sed -e <span style=color:#a5d6ff>&#34;s/%VAULT_DOCKER_ADDRESS%/</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>VAULT_DOCKER_ADDRESS</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/g&#34;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    <span style=color:#a5d6ff>&lt;&lt;EOF &gt; /tmp/vault-issuer.yaml
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>apiVersion: cert-manager.io/v1
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>kind: ClusterIssuer
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>metadata:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  name: vault-issuer
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  namespace: cert-manager
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>spec:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  vault:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    path: pki/root/sign-intermediate
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    server: http://%VAULT_DOCKER_ADDRESS%:8200
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    auth:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>      tokenSecretRef:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>         name: my-secret-token
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>         key: token
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>EOF</span>
</span></span></code></pre></div><p>(If you look at <code>/tmp/vault-issuer.yaml</code>, you&rsquo;ll see that the <code>server</code> element
has the correct IP address in it.) Let&rsquo;s go ahead and apply that, then check to
make sure it&rsquo;s happy.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f /tmp/vault-issuer.yaml
</span></span><span style=display:flex><span>kubectl get clusterissuers -o wide
</span></span></code></pre></div><p>You should see the <code>vault-issuer</code> show with <code>READY</code> true and <code>STATUS</code> &ldquo;Vault
verified&rdquo;, telling us that cert-manager was able to talk to Vault.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME           READY   STATUS           AGE
</span></span><span style=display:flex><span>vault-issuer   True    Vault verified   6s
</span></span></code></pre></div><p>Now that cert-manager can sign our certificates, let&rsquo;s go ahead and tell
cert-manager how to set things up for Linkerd. First, we&rsquo;ll use a Certificate
resource to tell cert-manager how to use the Vault issuer to issue our identity
issuer certificate:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f - <span style=color:#a5d6ff>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>apiVersion: cert-manager.io/v1
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>kind: Certificate
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>metadata:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  name: linkerd-identity-issuer
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  namespace: linkerd
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>spec:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  secretName: linkerd-identity-issuer
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  duration: 48h
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  renewBefore: 25h
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  issuerRef:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    name: vault-issuer
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    kind: ClusterIssuer
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  commonName: identity.linkerd.cluster.local
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  dnsNames:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  - identity.linkerd.cluster.local
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  isCA: true
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  privateKey:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    algorithm: ECDSA
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  usages:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  - cert sign
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  - crl sign
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  - server auth
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  - client auth
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>EOF</span>
</span></span></code></pre></div><p><strong>NOTE</strong> that this Certificate goes in the <code>linkerd</code> namespace, <strong>not</strong> the
<code>cert-manager</code> namespace! This is because Linkerd actually needs access to the
identity issuer, so we have cert-manager create it where it will need to be
used.</p><p>Running <code>kubectl get certificate -n linkerd</code> at this point should show our
Certificate with <code>READY</code> true:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                      READY   SECRET                    AGE
</span></span><span style=display:flex><span>linkerd-identity-issuer   True    linkerd-identity-issuer   11s
</span></span></code></pre></div><p>and if we <code>kubectl describe secret -n linkerd linkerd-identity-issuer</code> we should
see a <code>kubernetes.io/tls</code> Secret with keys of <code>ca.crt</code>, <code>tls.crt</code>, and
<code>tls.key</code>:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Name:         linkerd-identity-issuer
</span></span><span style=display:flex><span>Namespace:    linkerd
</span></span><span style=display:flex><span>Labels:       controller.cert-manager.io/fao=true
</span></span><span style=display:flex><span>Annotations:  cert-manager.io/alt-names: identity.linkerd.cluster.local
</span></span><span style=display:flex><span>              cert-manager.io/certificate-name: linkerd-identity-issuer
</span></span><span style=display:flex><span>              cert-manager.io/common-name: identity.linkerd.cluster.local
</span></span><span style=display:flex><span>              cert-manager.io/ip-sans:
</span></span><span style=display:flex><span>              cert-manager.io/issuer-group:
</span></span><span style=display:flex><span>              cert-manager.io/issuer-kind: ClusterIssuer
</span></span><span style=display:flex><span>              cert-manager.io/issuer-name: vault-issuer
</span></span><span style=display:flex><span>              cert-manager.io/uri-sans:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type:  kubernetes.io/tls
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Data
</span></span><span style=display:flex><span>====
</span></span><span style=display:flex><span>ca.crt:   851 bytes
</span></span><span style=display:flex><span>tls.crt:  863 bytes
</span></span><span style=display:flex><span>tls.key:  227 bytes
</span></span></code></pre></div><p>Finally, we&rsquo;ll use a Bundle resource to tell trust-manager to copy only the
public half of the trust anchor into a ConfigMap for Linkerd to use. Note that
Bundles are always cluster-scoped &ndash; but also note that the reason we don&rsquo;t have
to specify namespaces for the source and destination is that trust-manager can
only read from its trust namespace, in this case <code>linkerd</code>, and it defaults to
writing there too.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f - <span style=color:#a5d6ff>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>apiVersion: trust.cert-manager.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>kind: Bundle
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>metadata:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  name: linkerd-identity-trust-roots
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>spec:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  sources:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  - secret:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>      name: &#34;linkerd-identity-issuer&#34;
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>      key: &#34;ca.crt&#34;
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  target:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    configMap:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>      key: &#34;ca-bundle.crt&#34;
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>EOF</span>
</span></span></code></pre></div><p>At this point, <code>kubectl get bundle</code> (remember, it&rsquo;s cluster-scoped!) should show
us a Bundle named <code>linkerd-identity-trust-roots</code> with <code>SYNCED</code> true:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>NAME                           TARGET   SYNCED   REASON   AGE
</span></span><span style=display:flex><span>linkerd-identity-trust-roots            True     Synced   4s
</span></span></code></pre></div><h2 id=installing-linkerd>Installing Linkerd</h2><p><strong>Finally</strong> we&rsquo;re ready to deploy Linkerd! We may as well use Helm for this,
too. Start by setting up Helm repos:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm repo add --force-update linkerd https://helm.linkerd.io/stable
</span></span><span style=display:flex><span>helm repo update
</span></span></code></pre></div><p>&mldr;then install the Linkerd CRDs.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install linkerd-crds -n linkerd linkerd/linkerd-crds
</span></span></code></pre></div><p>After that we can actually install Linkerd! Pay attention to these <code>--set</code>
parameters we pass here:</p><ul><li><code>identity.issuer.scheme=kubernetes.io/tls</code> tells Helm that it should expect
the identity issuer to already exist, so don&rsquo;t try to create one, and</li><li><code>identity.externalCA=true</code> tells Helm that it should expect the trust bundle
to already exist, too.</li></ul><p>These things, of course, are being handled by cert-manager and trust-manager.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>helm install linkerd-control-plane linkerd/linkerd-control-plane <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>     -n linkerd <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>     --set identity.issuer.scheme<span style=color:#ff7b72;font-weight:700>=</span>kubernetes.io/tls <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>     --set identity.externalCA<span style=color:#ff7b72;font-weight:700>=</span>true
</span></span></code></pre></div><p>Once that&rsquo;s done, we can use <code>linkerd check</code> to validate that everything worked:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd check
</span></span></code></pre></div><p>Note that we see a warning for the identity issuer certificate not being valid
for at least 60 days. That&rsquo;s expected, since we created that with a 48-hour
lifespan!</p><h2 id=summary>Summary</h2><p>After all that, we have Vault generating all our certificates, cert-manager and
trust-manager handling rotating and distributing them as needed, and Linkerd
consuming them for mTLS everywhere.</p><p>Critically, Vault is <em>not running in our cluster</em>, and if you look back over
this whole process, the private key for the trust anchor has never been revealed
outside of Vault. Using an external CA to isolate key generation lets us
dramatically increase security of the overall system.</p><p>Vault, of course, isn&rsquo;t the only external CA we can use: cert-manager supports a
lot of different issuers, including ACME, Vault, Venafi, and many others issuers
(see the
<a href=https://cert-manager.io/docs/configuration/external/ target=_blank rel=noopener>cert-manager documentation</a>
for more about this). We used Vault for this workshop because it&rsquo;s free to use
and relatively easy to set up in Docker, but you&rsquo;re encouraged to try other
kinds of external CAs &ndash; ultimately, the critical bit isn&rsquo;t which one you use,
it&rsquo;s that you&rsquo;re keeping your secret keys secret.</p><hr><p><em>If you found this interesting, check out the Service Mesh Academy workshop on
<a href=https://buoyant.io/service-mesh-academy/linkerd-with-external-cas-using-vault target=_blank rel=noopener>Linkerd with external CAs using Vault</a>,
where you can see the hands-on demo of everything I&rsquo;ve talked about here! And,
as always, feedback is always welcome &ndash; you can find me as <code>@flynn</code> on the
<a href=https://slack.linkerd.io target=_blank rel=noopener>Linkerd Slack</a>.</em></p></div></div><div class=blog-post-related><h2>Suggested Blog Posts</h2><div class=blog-post-related__pages><div class="card card--horz card--center"><div class=card__media><img src=/2024/02/21/announcing-linkerd-2.15/cover.jpg alt=Cover class="img img--128 img--rounded"></div><div class=card__body><div class=card__header><h4><a href=/2024/02/21/announcing-linkerd-2.15/>Announcing Linkerd 2.15 with mesh expansion, native sidecars, and SPIFFE</a></h4><div class=blog-post-meta><div class=blog-post-meta__date>Feb 21, 2024 • 8 min read</div></div></div></div></div><div class="card card--horz card--center"><div class=card__media><img src=/2023/09/12/linkerd-214/thumbnail.jpg alt=Thumbnail class="img img--128 img--rounded"></div><div class=card__body><div class=card__header><h4><a href=/2023/09/12/linkerd-214/>Workshop Recap: A closer look at flat-network multicluster and HTTPRoute timeouts with Linkerd 2.14</a></h4><div class=blog-post-meta><div class=blog-post-meta__date>Sep 12, 2023 • 6 min read</div></div></div></div></div><div class="card card--horz card--center"><div class=card__media><img src=/2024/08/13/announcing-linkerd-2.16/cover.jpg alt=Cover class="img img--128 img--rounded"></div><div class=card__body><div class=card__header><h4><a href=/2024/08/13/announcing-linkerd-2.16/>Announcing Linkerd 2.16! Metrics, retries, and timeouts for HTTP and gRPC
routes; IPv6 support; policy audit mode; and lots more</a></h4><div class=blog-post-meta><div class=blog-post-meta__date>Aug 13, 2024 • 6 min read</div></div></div></div></div></div></div></div></div></main><footer class=main-footer><div class=main-footer__top><div class="main-footer__container container"><div class=main-footer__info><p><img src=/logos/linkerd.png alt=Linkerd></p><p>Linkerd was originally created by <a href=https://buoyant.io/ target=_blank rel=noopener>Buoyant</a></p><p>View <a href=https://github.com/linkerd/linkerd/wiki/Linkerd-code-of-conduct target=_blank rel=noopener>Code of Conduct</a></p></div><div class=main-footer__links><div class=main-footer__community><h4>Community</h4><ul><li><a href=https://github.com/linkerd/linkerd2 target=_blank rel=noopener>GitHub</a></li><li><a href=https://slack.linkerd.io target=_blank rel=noopener>Slack</a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener>Linkerd Forum</a></li></ul></div><div class=main-footer__follow><h4>Follow</h4><ul><li><a href=https://www.linkedin.com/company/linkerd/ target=_blank rel=noopener>Linkedin</a></li><li><a href=https://www.youtube.com/buoyantio target=_blank rel=noopener>YouTube</a></li><li><a href=https://twitter.com/linkerd target=_blank rel=noopener>Twitter</a></li></ul></div></div></div></div><div class=main-footer__bottom><div class="main-footer__container container"><p><a href=https://github.com/linkerd/website/tree/main/linkerd.io/content target=_blank rel=noopener>Edit This Site</a></p><p>Copyright © 2024 Linkerd Authors. All rights reserved.</p></div></div></footer></body></html>