<!doctype html><html lang=en><head><meta charset=utf-8><title>Service Mesh Glossary | Linkerd</title>
<link rel="shortcut icon" href=/favicon.png><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="This glossary covers the most important service mesh concepts. Whether latency, sidecar proxy, or success rate, you'll find a succinct definition for each term."><meta property="og:url" content="https://travisbeckham.github.io/service-mesh-glossary/"><meta property="og:site_name" content="Linkerd"><meta property="og:title" content="Service Mesh Glossary"><meta property="og:description" content="This glossary covers the most important service mesh concepts. Whether latency, sidecar proxy, or success rate, you'll find a succinct definition for each term."><meta property="og:locale" content="en_us"><meta property="og:type" content="website"><meta property="og:image" content="https://travisbeckham.github.io/logos/linkerd.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://travisbeckham.github.io/logos/linkerd.png"><meta name=twitter:title content="Service Mesh Glossary"><meta name=twitter:description content="This glossary covers the most important service mesh concepts. Whether latency, sidecar proxy, or success rate, you'll find a succinct definition for each term."><meta name=twitter:site content="@Linkerd"><link rel=canonical href=https://travisbeckham.github.io/service-mesh-glossary/><link rel=stylesheet href=/css/main.css><script src=/js/main.js></script><script async defer src=https://buttons.github.io/buttons.js></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"FAQPage","mainEntity":[{"@type":"Question","name":"What is an API gateway?","acceptedAnswer":{"@type":"Answer","text":"An API gateway sits in front of an app and is designed to solve\nbusiness problems like authentication and authorization, rate limiting,\nand providing a common access point for external consumers. A service\nmesh, in contrast, is focused on providing operational logic between\ncomponents of the app."}},{"@type":"Question","name":"What is a cluster?","acceptedAnswer":{"@type":"Answer","text":"In the cloud native context, a cluster is a group of machines, physical\nor virtual, that make up the pool of hardware on which a container\norchestrator such as Kubernetes can run. Each machine in the cluster is\ncommonly referred to as a node."}},{"@type":"Question","name":"What is a container?","acceptedAnswer":{"@type":"Answer","text":"A container is a lightweight packaging of an application and its\ndependencies, designed to be run by a host operating system (OS) in an\nisolated fashion with strict limits on resource consumption and access\nto the OS."}},{"@type":"Question","name":"What is a service mesh control plane?","acceptedAnswer":{"@type":"Answer","text":"The control plane of a service mesh provides the command and control signals required for the data plane to operate. The control plane controls the data plane and provides the UI and API that operators use to configure, monitor, and operate the mesh."}},{"@type":"Question","name":"What is a data plane?","acceptedAnswer":{"@type":"Answer","text":"The data plane of a service mesh comprises the deployment of its sidecar proxies that intercept in-mesh application traffic. The data plane is responsible for gathering metrics, observing traffic, and applying policy."}},{"@type":"Question","name":"What is distributed tracing?","acceptedAnswer":{"@type":"Answer","text":"In a microservices-based system, an individual request from a client\ntypically triggers a series of requests across a number of services.\nDistributed tracing is the practice of \u0026ldquo;tracing\u0026rdquo;, or following, these\nrequests as they move through the distributed system for reasons of\nperformance monitoring or debugging."}},{"@type":"Question","name":"What is egress?","acceptedAnswer":{"@type":"Answer","text":"In the context of a Kubernetes cluster, \u0026ldquo;egress\u0026rdquo; refers to traffic\nleaving the cluster. Unlike with ingress traffic, there is no explicit\nKubernetes egress resource and, by default, egress traffic simply exits\nthe cluster."}},{"@type":"Question","name":"What is Enterprise Service Bus (ESB)?","acceptedAnswer":{"@type":"Answer","text":"An ESB is a tool and architectural pattern that largely predates modern\nmicroservice architectures. ESBs were used to manage communication in a\nservice-oriented architecture, handling everything from inter-app\ncommunication, data transformation, message routing, and message queuing\nfunctionality."}},{"@type":"Question","name":"What are golden metrics?","acceptedAnswer":{"@type":"Answer","text":"Golden metrics, or golden signals, are the core metrics of application health. The set of golden metrics is generally defined as latency, traffic volume, error rate, and saturation. Linkerd\u0026rsquo;s golden metrics omit saturation."}},{"@type":"Question","name":"What is an ingress?","acceptedAnswer":{"@type":"Answer","text":"An ingress is a specific application that runs in a Kubernetes cluster\nand handles traffic coming into the cluster from off-cluster sources.\nThis traffic is referred to as ingress (or occasionally \u0026ldquo;north/south\u0026rdquo;\ntraffic)"}},{"@type":"Question","name":"What is an init container?","acceptedAnswer":{"@type":"Answer","text":"An init container is a container run at the beginning of the pod\nlifecycle before the application containers start. Typical use cases of\ninit containers include rewriting network rules; assembling secrets for\nthe application; and copying files from a network location."}},{"@type":"Question","name":"What is latency?","acceptedAnswer":{"@type":"Answer","text":"Latency refers to the time it takes an application to do something\n(e.g., processing a request, populating data, etc.) In service mesh\nterms, this is measured at the response level, i.e. by timing how long\nthe application takes to respond to a request."}},{"@type":"Question","name":"What is Linkerd?","acceptedAnswer":{"@type":"Answer","text":"Linkerd was the first service mesh and the project that defined the\nterm \u0026ldquo;service mesh\u0026rdquo; itself. First released 2016, Linkerd is designed to\nbe the fastest, lightest-weight service mesh possible for Kubernetes.\nLinkerd is a Cloud Native Computing Foundation (CNCF) graduated project."}},{"@type":"Question","name":"What is load balancing?","acceptedAnswer":{"@type":"Answer","text":"Load balancing is the act of distributing work across a number of\nequivalent endpoints. Kubernetes, like many systems, provides load\nbalancing at the connection level. A service mesh like Linkerd improves\nthis by performing load balancing at the request level."}},{"@type":"Question","name":"What is mTLS?","acceptedAnswer":{"@type":"Answer","text":"Mutual TLS (mTLS) is a way to authenticate and encrypt a connection\nbetween two endpoints. Mutual TLS is simply the standard Transport Layer\nSecurity (TLS) protocol, with the additional restriction that identity\non both sides of the connection must be validated."}},{"@type":"Question","name":"What is multi-cluster?","acceptedAnswer":{"@type":"Answer","text":"In the context of Kubernetes, multi-cluster usually refers to running\nan application \u0026ldquo;across\u0026rdquo; multiple Kubernetes clusters. Linkerd\u0026rsquo;s\nmulti-cluster support provides seamless and secured communication across\nclusters, in a way that\u0026rsquo;s secure even across the public Internet."}},{"@type":"Question","name":"What is observability?","acceptedAnswer":{"@type":"Answer","text":"Observability is the ability to understand the health and performance\nof a system from the data it generates. In the context of service\nmeshes, observability generally refers to the data about a system that\nthe service mesh can report."}},{"@type":"Question","name":"What is reliability?","acceptedAnswer":{"@type":"Answer","text":"Reliability is a system property that measures how well the system\nresponds to failure. The more reliable a system is, the better it can\nhandle individual components being down or degraded."}},{"@type":"Question","name":"What is a service mesh?","acceptedAnswer":{"@type":"Answer","text":"A service mesh is a tool for adding observability, security, and reliability features to applications by inserting these features at the platform layer rather than the application layer. Service meshes are implemented by adding sidecar proxies that intercept all traffic between applications."}},{"@type":"Question","name":"What is a sidecar proxy?","acceptedAnswer":{"@type":"Answer","text":"A sidecar proxy is a proxy that is deployed alongside the applications\nin the mesh. (In Kubernetes, as a container within the application\u0026rsquo;s\npod.) The sidecar proxy intercepts network calls to and from the\napplications and is responsible for implementing any control\nplane](#control-plane)’s logic or rules."}},{"@type":"Question","name":"What is the Success rate?","acceptedAnswer":{"@type":"Answer","text":"Success rate refers to the percentage of requests that our application\nresponds to successfully. For HTTP traffic, for example, this is\nmeasured as the proportion of 2xx or 4xx responses over total responses."}}]}</script></head><body><header class=main-header><div class=main-header__container><div class=main-header__logo><a href=/><img src=/logos/linkerd.png alt=Linkerd></a></div><input class=main-header__toggle-checkbox type=checkbox id=main-header-toggle>
<label class=main-header__toggle for=main-header-toggle><span class=main-header__toggle-icon><span class=main-header__toggle-icon--open><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3 6H21V8H3V6m0 5H21v2H3V11m0 5H21v2H3V16z"/></svg>
</span><span class=main-header__toggle-icon--close><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg></span></span></label><div class=main-header__nav><nav class=main-nav><ul class=main-nav__menu><li><a href=/docs>Docs</a></li><li><a href=#>Community<svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M7.41 8.58 12 13.17l4.59-4.59L18 10l-6 6-6-6L7.41 8.58z"/></svg></a><ul><li><a href=/community/get-involved/>Get Involved</a></li><li><a href=/community/adopters/>Adopters</a></li><li><a href=/community/ambassadors/>Linkerd Ambassadors</a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener>Buoyant's Linkerd Forum</a></li></ul></li><li><a href=/blog/>Blog</a></li><li><a href=/faq/>FAQ</a></li><li><a href=/enterprise/>Enterprise</a></li></ul><div class=main-nav__search><form action=/search method=get><div class="search-input search-input--sm"><svg class="icon" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5.0 0116 9.5c0 1.61-.59 3.09-1.56 4.23L14.71 14H15.5l5 5L19 20.5l-5-5V14.71L13.73 14.44C12.59 15.41 11.11 16 9.5 16A6.5 6.5.0 013 9.5 6.5 6.5.0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
<input type=text name=q placeholder=Search></div></form></div><div class=main-nav__github><a class=github-button href=https://github.com/linkerd/linkerd2 data-icon=octicon-star data-size=large data-show-count=true aria-label="Star linkerd/linkerd2 on GitHub">Star</a></div><div class=main-nav__forum><a href=https://linkerd.buoyant.io class="button button--primary button--sm" target=_blank rel=noopener>Join Forum</a></div></nav></div></div></header><div class=main-announcement><strong>Oct 23, 2024</strong> New blog post: Towards a Sustainable Service Mesh.
<a href=/2024/10/23/making-linkerd-sustainable/ class=main-announcement__link>Read the post</a></div><main class=main-content><div class=docs><div class=docs__container><div class=docs__sidebar><div class=docs__nav><div class=docs__versions><select onchange="window.location.href=this.value"><option value=/2-edge/>Linkerd edge</option><option value=/2.16/ selected>Linkerd 2.16</option><option value=/2.15/>Linkerd 2.15</option><option value=/2.14/>Linkerd 2.14</option><option value=/2.13/>Linkerd 2.13</option><option value=/2.12/>Linkerd 2.12</option><option value=/2.11/>Linkerd 2.11</option><option value=/2.10/>Linkerd 2.10</option></select></div><nav><ul><li><a href=/2.16/overview/>Overview</a></li><li><a href=/2.16/getting-started/>Getting Started</a></li><li><a href=/2.16/features/>Features
</a><input class=toggle__input type=checkbox id=toggle-8f2b3864989abf5fcedb56a3ffaa68dd>
<label class=toggle__label for=toggle-8f2b3864989abf5fcedb56a3ffaa68dd><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.16/features/http-grpc/>HTTP, HTTP/2, and gRPC Proxying</a></li><li><a href=/2.16/features/protocol-detection/>TCP Proxying and Protocol Detection</a></li><li><a href=/2.16/features/retries-and-timeouts/>Retries and Timeouts</a></li><li><a href=/2.16/features/automatic-mtls/>Automatic mTLS</a></li><li><a href=/2.16/features/ingress/>Ingress</a></li><li><a href=/2.16/features/telemetry/>Telemetry and Monitoring</a></li><li><a href=/2.16/features/load-balancing/>Load Balancing</a></li><li><a href=/2.16/features/server-policy/>Authorization Policy</a></li><li><a href=/2.16/features/proxy-injection/>Automatic Proxy Injection</a></li><li><a href=/2.16/features/cni/>CNI Plugin</a></li><li><a href=/2.16/features/dashboard/>Dashboard and on-cluster metrics stack</a></li><li><a href=/2.16/features/distributed-tracing/>Distributed Tracing</a></li><li><a href=/2.16/features/request-routing/>Dynamic Request Routing</a></li><li><a href=/2.16/features/fault-injection/>Fault Injection</a></li><li><a href=/2.16/features/ha/>High Availability</a></li><li><a href=/2.16/features/access-logging/>HTTP Access Logging</a></li><li><a href=/2.16/features/httproute/>HTTPRoutes</a></li><li><a href=/2.16/features/nft/>Iptables-nft Support</a></li><li><a href=/2.16/features/ipv6/>IPv6 Support</a></li><li><a href=/2.16/features/multicluster/>Multi-cluster communication</a></li><li><a href=/2.16/features/non-kubernetes-workloads/>Non-Kubernetes workloads (mesh expansion)</a></li><li><a href=/2.16/features/service-profiles/>Service Profiles</a></li><li><a href=/2.16/features/traffic-split/>Traffic Split (canaries, blue/green deploys)</a></li></ul></li><li><a href=/2.16/tasks/>Tasks
</a><input class=toggle__input type=checkbox id=toggle-6dd1ab63beb6e01f692b7628aa14c0a7>
<label class=toggle__label for=toggle-6dd1ab63beb6e01f692b7628aa14c0a7><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.16/tasks/adding-non-kubernetes-workloads/>Adding non-Kubernetes workloads to your mesh</a></li><li><a href=/2.16/tasks/adding-your-service/>Adding your services to Linkerd</a></li><li><a href=/2.16/tasks/automatic-failover/>Automatic Multicluster Failover</a></li><li><a href=/2.16/tasks/automatically-rotating-control-plane-tls-credentials/>Automatically Rotating Control Plane TLS Credentials</a></li><li><a href=/2.16/tasks/automatically-rotating-webhook-tls-credentials/>Automatically Rotating Webhook TLS Credentials</a></li><li><a href=/2.16/tasks/external-prometheus/>Bringing your own Prometheus</a></li><li><a href=/2.16/tasks/circuit-breakers/>Circuit Breakers</a></li><li><a href=/2.16/tasks/configuring-dynamic-request-routing/>Configuring Dynamic Request Routing</a></li><li><a href=/2.16/tasks/configuring-per-route-policy/>Configuring Per-Route Authorization Policy</a></li><li><a href=/2.16/tasks/configuring-proxy-concurrency/>Configuring Proxy Concurrency</a></li><li><a href=/2.16/tasks/configuring-proxy-discovery-cache/>Configuring Proxy Discovery Cache</a></li><li><a href=/2.16/tasks/configuring-retries/>Configuring Retries</a></li><li><a href=/2.16/tasks/configuring-timeouts/>Configuring Timeouts</a></li><li><a href=/2.16/tasks/using-debug-endpoints/>Control Plane Debug Endpoints</a></li><li><a href=/2.16/tasks/customize-install/>Customizing Linkerd's Configuration with Kustomize</a></li><li><a href=/2.16/tasks/debugging-502s/>Debugging 502s</a></li><li><a href=/2.16/tasks/debugging-your-service/>Debugging gRPC applications with request tracing</a></li><li><a href=/2.16/tasks/books/>Debugging HTTP applications with per-route metrics</a></li><li><a href=/2.16/tasks/distributed-tracing/>Distributed tracing with Linkerd</a></li><li><a href=/2.16/tasks/exporting-metrics/>Exporting Metrics</a></li><li><a href=/2.16/tasks/exposing-dashboard/>Exposing the Dashboard</a></li><li><a href=/2.16/tasks/generate-certificates/>Generating your own mTLS root certificates</a></li><li><a href=/2.16/tasks/getting-per-route-metrics/>Getting Per-Route Metrics</a></li><li><a href=/2.16/tasks/linkerd-smi/>Getting started with Linkerd SMI extension</a></li><li><a href=/2.16/tasks/graceful-shutdown/>Graceful Pod Shutdown</a></li><li><a href=/2.16/tasks/grafana/>Grafana</a></li><li><a href=/2.16/tasks/using-ingress/>Handling ingress traffic</a></li><li><a href=/2.16/tasks/fault-injection/>Injecting Faults</a></li><li><a href=/2.16/tasks/install/>Installing Linkerd</a></li><li><a href=/2.16/tasks/install-helm/>Installing Linkerd with Helm</a></li><li><a href=/2.16/tasks/installing-multicluster/>Installing Multi-cluster Components</a></li><li><a href=/2.16/tasks/using-psp/>Linkerd and Pod Security Policies (PSP)</a></li><li><a href=/2.16/tasks/manually-rotating-control-plane-tls-credentials/>Manually Rotating Control Plane TLS Credentials</a></li><li><a href=/2.16/tasks/modifying-proxy-log-level/>Modifying the Proxy Log Level</a></li><li><a href=/2.16/tasks/multicluster/>Multi-cluster communication</a></li><li><a href=/2.16/tasks/multicluster-using-statefulsets/>Multi-cluster communication with StatefulSets</a></li><li><a href=/2.16/tasks/per-request-policy/>Per-Request Policy</a></li><li><a href=/2.16/tasks/pod-to-pod-multicluster/>Pod-to-Pod Multi-cluster communication</a></li><li><a href=/2.16/tasks/flagger/>Progressive Delivery</a></li><li><a href=/2.16/tasks/replacing_expired_certificates/>Replacing expired certificates</a></li><li><a href=/2.16/tasks/restricting-access/>Restricting Access To Services</a></li><li><a href=/2.16/tasks/rotating_webhooks_certificates/>Rotating webhooks certificates</a></li><li><a href=/2.16/tasks/securing-linkerd-tap/>Securing Linkerd Tap</a></li><li><a href=/2.16/tasks/setting-up-service-profiles/>Setting Up Service Profiles</a></li><li><a href=/2.16/tasks/traffic-shifting/>Traffic Shifting</a></li><li><a href=/2.16/tasks/troubleshooting/>Troubleshooting</a></li><li><a href=/2.16/tasks/uninstall/>Uninstalling Linkerd</a></li><li><a href=/2.16/tasks/uninstall-multicluster/>Uninstalling Multicluster</a></li><li><a href=/2.16/tasks/upgrade/>Upgrading Linkerd</a></li><li><a href=/2.16/tasks/using-custom-domain/>Using a Custom Cluster Domain</a></li><li><a href=/2.16/tasks/extensions/>Using extensions</a></li><li><a href=/2.16/tasks/gitops/>Using GitOps with Linkerd with Argo CD</a></li><li><a href=/2.16/tasks/using-the-debug-container/>Using the Debug Sidecar</a></li><li><a href=/2.16/tasks/validating-your-traffic/>Validating your mTLS traffic</a></li></ul></li><li><a href=/2.16/reference/>Reference
</a><input class=toggle__input type=checkbox id=toggle-f7bbb952d9a479cfe82f5debb0fbc89c>
<label class=toggle__label for=toggle-f7bbb952d9a479cfe82f5debb0fbc89c><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.16/reference/architecture/>Architecture</a></li><li><a href=/2.16/reference/authorization-policy/>Authorization Policy</a></li><li><a href=/2.16/reference/circuit-breaking/>Circuit Breaking</a></li><li><a href=/2.16/reference/cli/>CLI
</a><input class=toggle__input type=checkbox id=toggle-16e73a448bb99ac0d4654e9aeb3859cd>
<label class=toggle__label for=toggle-16e73a448bb99ac0d4654e9aeb3859cd><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.16/reference/cli/authz/>authz</a></li><li><a href=/2.16/reference/cli/check/>check</a></li><li><a href=/2.16/reference/cli/completion/>completion</a></li><li><a href=/2.16/reference/cli/diagnostics/>diagnostics</a></li><li><a href=/2.16/reference/cli/identity/>identity</a></li><li><a href=/2.16/reference/cli/inject/>inject</a></li><li><a href=/2.16/reference/cli/install/>install</a></li><li><a href=/2.16/reference/cli/install-cni/>install-cni</a></li><li><a href=/2.16/reference/cli/jaeger/>jaeger</a></li><li><a href=/2.16/reference/cli/multicluster/>multicluster</a></li><li><a href=/2.16/reference/cli/profile/>profile</a></li><li><a href=/2.16/reference/cli/prune/>prune</a></li><li><a href=/2.16/reference/cli/uninject/>uninject</a></li><li><a href=/2.16/reference/cli/uninstall/>uninstall</a></li><li><a href=/2.16/reference/cli/upgrade/>upgrade</a></li><li><a href=/2.16/reference/cli/version/>version</a></li><li><a href=/2.16/reference/cli/viz/>viz</a></li></ul></li><li><a href=/2.16/reference/cluster-configuration/>Cluster Configuration</a></li><li><a href=/2.16/reference/extension-list/>Extensions List</a></li><li><a href=/2.16/reference/external-workload/>ExternalWorkload</a></li><li><a href=/2.16/reference/httproute/>HTTPRoute</a></li><li><a href=/2.16/reference/iptables/>IPTables Reference</a></li><li><a href=/2.16/reference/multicluster/>Multi-cluster communication</a></li><li><a href=/2.16/reference/proxy-configuration/>Proxy Configuration</a></li><li><a href=/2.16/reference/proxy-log-level/>Proxy Log Level</a></li><li><a href=/2.16/reference/proxy-metrics/>Proxy Metrics</a></li><li><a href=/2.16/reference/retries/>Retries</a></li><li><a href=/2.16/reference/service-profiles/>Service Profiles</a></li><li><a href=/2.16/reference/k8s-versions/>Supported Kubernetes Versions</a></li><li><a href=/2.16/reference/timeouts/>Timeouts</a></li></ul></li><li><a href=/2.16/common-errors/>Common Errors
</a><input class=toggle__input type=checkbox id=toggle-1dfe2f36d6b5e88e61f40a60319ec82c>
<label class=toggle__label for=toggle-1dfe2f36d6b5e88e61f40a60319ec82c><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.16/common-errors/failfast/>Failfast</a></li><li><a href=/2.16/common-errors/http-502/>HTTP 502 Errors</a></li><li><a href=/2.16/common-errors/http-503-504/>HTTP 503 and 504 Errors</a></li><li><a href=/2.16/common-errors/protocol-detection/>Protocol Detection Errors</a></li></ul></li></ul><ul><li><a href=/what-is-a-service-mesh/>What is a service mesh?</a></li><li><a href=/faq/>Frequently Asked Questions</a></li><li><a href=/releases/>Releases and Versions</a></li><li><a href=/design-principles/>Design Principles</a></li><li><a href=/going-to-production/>Going to Production</a></li><li class=docs__nav--selected><a href=/service-mesh-glossary/>Service Mesh Glossary</a></li></ul></nav><div class=docs__community><ul><li><a href=https://github.com/linkerd/linkerd2 target=_blank rel=noopener><img src=/logos/github.svg alt=GitHub class=img></a></li><li><a href=https://slack.linkerd.io target=_blank rel=noopener><img src=/logos/slack.svg alt=Slack class=img></a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener><img src=/logos/forum.png alt="Linkerd Forum" class=img></a></li></ul></div></div></div><div class=docs__main><div class=docs__body><div class=docs__header><h1>Service Mesh Glossary</h1></div><div class="docs__content prose"><h2 id=api-gateway class=anchor>API Gateway
<a href=#api-gateway class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>An API gateway sits in front of an application and is designed to solve business
problems like authentication and authorization, rate limiting, and providing a
common access point for external consumers. A service mesh, in contrast, is
focused on providing operational (not business) logic between components of the
application.</p><h2 id=cluster class=anchor>Cluster
<a href=#cluster class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>In the cloud native context, a cluster is a group of machines, physical or
virtual, that make up the pool of hardware on which a container orchestrator
such as Kubernetes can run. Each machine in the cluster is commonly referred
to as a node, and the nodes of a cluster are typically uniform, fungible, and
interconnected.</p><h2 id=container class=anchor>Container
<a href=#container class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>A container is a lightweight packaging of an application and its dependencies,
designed to be run by a host operating system (OS) in an isolated fashion
with strict limits on resource consumption and access to the OS. In this
sense, a container is an atomic executable &ldquo;unit&rdquo; that can be run by the
OS without application-specific setup or configuration.</p><p>In the service mesh context, containers were popularized by Docker as a
lightweight alternative to virtual machines (VMs), which had similar
characteristics but were considerably heavier weight. The rise of containers,
in turn, gave rise to container orchestrators such as Kubernetes, which
allowed applications, when packaged as containers, to be automatically
scheduled across a pool of machines (called a &ldquo;<a href=#cluster>cluster</a>&rdquo;).
The rise of Kubernetes gave rise to the sidecar model of deployment,
which allowed <a href=#service-mesh>service meshes</a> like Linkerd to provide
their functionality in a way that was decoupled from the application
and did not impose a severe operational cost to the operator.</p><h2 id=control-plane class=anchor>Control Plane
<a href=#control-plane class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>The control plane of a service mesh provides the command and control signals
required for the <a href=#data-plane>data plane</a> to operate. The control plane controls
the data plane and provides the UI and API that operators use to configure,
monitor, and operate the mesh.</p><h2 id=data-plane class=anchor>Data Plane
<a href=#data-plane class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>The data plane of a service mesh comprises the deployment of its
<a href=#sidecar-proxy>sidecar proxies</a> that intercept in-mesh application traffic.
The data plane is responsible for gathering metrics, observing traffic, and
applying policy.</p><h2 id=distributed-tracing class=anchor>Distributed tracing
<a href=#distributed-tracing class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>In a microservices-based system, an individual request from a client typically
triggers a series of requests across a number of services. Distributed tracing
is the practice of &ldquo;tracing&rdquo;, or following, these requests as they move
through the distributed system for reasons of performance monitoring or
debugging. It is typically achieved by modifying the services to emit tracing
information, or &ldquo;spans,&rdquo; and aggregating them in a central store.</p><h2 id=egress class=anchor>Egress
<a href=#egress class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>In the context of a Kubernetes cluster, &ldquo;egress&rdquo; refers to traffic leaving the
cluster. Unlike with ingress traffic, there is no explicit Kubernetes egress
resource and, by default, egress traffic simply exits the cluster. When control
and monitoring of Kubernetes egress traffic is necessary, it is typically
implemented at the networking / CNI layer, or by adding an explicit egress
proxy.</p><h2 id=enterprise-service-bus-esb class=anchor>Enterprise Service Bus (ESB)
<a href=#enterprise-service-bus-esb class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>An ESB is a tool and architectural pattern that largely predates modern
microservice architectures. ESBs were used to manage communication in a
service-oriented architecture (SOA), handling everything from inter-app
communication, data transformation, message routing, and message queuing
functionality. In modern microservices applications, a service mesh like
Linkerd replaces much of the need for an ESB and provides improved
separation of concerns and reduction of SPOFs.</p><h2 id=golden-metrics class=anchor>Golden Metrics
<a href=#golden-metrics class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>Golden metrics, or golden signals, are the core metrics of application health.
The set of golden metrics is generally defined as <a href=#latency>latency</a>, traffic
volume, error rate, and saturation. Linkerd&rsquo;s golden metrics omit saturation.</p><h2 id=ingress class=anchor>Ingress
<a href=#ingress class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>An ingress is a specific application that runs in a Kubernetes
<a href=#cluster>cluster</a> and handles traffic coming into the cluster from
off-cluster sources. This traffic is referred to as ingress (or
occasionally &ldquo;north/south&rdquo; traffic). In contrast to in-cluster traffic,
which is typically mediated by the <a href=#service-mesh>service mesh</a>, ingress
traffic has a specific set of concerns arising from the fact that it
often comes from customer, third-party, or other non-application sources.
<a href=#api-gateway>API gateways</a> are often used as ingresses.</p><h2 id=init-container class=anchor>Init Container
<a href=#init-container class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>An init container is a container run at the beginning of the pod lifecycle,
before the application containers start. Typical use cases of init containers
include rewriting network rules; assembling secrets for the application;
and copying files from a network location. For example, Linkerd&rsquo;s init
container updates networking rules to direct all TCP traffic for the pod
through the Linkerd proxy container. An init container terminates before
the application container starts.</p><h2 id=latency class=anchor>Latency
<a href=#latency class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>Latency refers to the time it takes an application to do something (e.g.,
processing a request, populating data, etc.) In <a href=#service-mesh>service mesh</a>
terms, this is
measured at the response level, i.e. by timing how long the application takes to
respond to a request. Latency is typically characterized by the percentiles of a
distribution, commonly including the p50 (or median), the p95 (or 95th
percentile), the p99 (or 99th percentile), and so on.</p><h2 id=linkerd class=anchor>Linkerd
<a href=#linkerd class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>Linkerd was the first <a href=#service-mesh>service mesh</a> and the project that
defined the term
&ldquo;service mesh&rdquo; itself. First released 2016, Linkerd is designed to be the
fastest, lightest-weight service mesh possible for Kubernetes. Linkerd is a
Cloud Native Computing Foundation (CNCF) graduated project.</p><h2 id=load-balancing class=anchor>Load balancing
<a href=#load-balancing class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>Load balancing is the act of distributing work across a number of equivalent
endpoints. Kubernetes, like many systems, provides load balancing at the
connection level. A service mesh like Linkerd improves this by performing
load balancing at the request level, which allows it to take into account
factors such as the performance of individual endpoints.</p><p>Load balancing at the request level also allows Linkerd to effectively
load balance requests for systems that use gRPC (and HTTP/2 more generally),
which multiplex requests across a single connection—Kubernetes itself
cannot effectively load balance these systems because there is typically
only one connection ever made.</p><p>Load balancing algorithms decide which endpoint will serve a given request.
The most common is &ldquo;round-robin,&rdquo; which simply iterates across all endpoints.
More advanced balancing algorithms include &ldquo;least loaded,&rdquo; which distributes
load based on the number of outstanding requests for each endpoint.
Linkerd itself uses a sophisticated latency-aware load balancing algorithm
called EWMA (exponentially-weighted moving average), to distribute load
based on endpoint latency while being responsive to rapid changes in the
latency profile of individual endpoints.</p><h2 id=mtls class=anchor>mTLS
<a href=#mtls class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>Mutual TLS (mTLS) is a way to <a href=https://linkerd.io/2/features/automatic-mtls/ target=_blank rel=noopener>authenticate and encrypt a connection between
two endpoints</a>.
Mutual TLS is simply the standard Transport Layer Security
(TLS) protocol, with the additional restriction that identity on both sides
of the connection must be validated. (The use of TLS in web browsers, for
example, typically only validates the identity of the server, not the client.)</p><p>In the service mesh context, mTLS is the basic mechanism for validating the
identity of services on either side of a connection and for keeping that
communication confidential. This validation of identity is the basis for
policy enforcement.</p><h2 id=multi-cluster class=anchor>Multi-cluster
<a href=#multi-cluster class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>In the context of Kubernetes, multi-cluster usually refers to running
an application &ldquo;across&rdquo; multiple Kubernetes clusters. Linkerd&rsquo;s multi-cluster
support provides seamless and secured communication across clusters, in a
way that&rsquo;s secure even across the public Internet, and is fully transparent
to the application itself.</p><h2 id=observability class=anchor>Observability
<a href=#observability class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>Observability is the ability to understand the health and performance of
a system from the data it generates. In the context of service meshes,
observability generally refers to the data about a system that the
service mesh can report. This includes things like
&ldquo;<a href=#golden-metrics>golden metrics</a>&rdquo;,
service topology graphs of dependencies, traffic sampling, and so on.</p><h2 id=reliability class=anchor>Reliability
<a href=#reliability class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>Reliability is a system property that measures how well the system
responds to failure. The more reliable a system is, the better it
can handle individual components being down or degraded. For
multi-service or microservice applications, a service mesh can
be used to increase the reliability by applying<a href=https://linkerd.io/2/features/retries-and-timeouts/ target=_blank rel=noopener>techniques
like retries and timeouts</a>
to cross-service calls, by <a href=https://linkerd.io/2/features/load-balancing/ target=_blank rel=noopener>load balancing
in intelligent ways</a>,
by <a href=https://linkerd.io/2/features/traffic-split/ target=_blank rel=noopener>shifting traffic</a>
in the presence of errors, and so on.</p><h2 id=service-mesh class=anchor>Service mesh
<a href=#service-mesh class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>A service mesh is a tool for adding <a href=#observability>observability</a>,
security, and <a href=#reliability>reliability</a>
features to applications by inserting these features at the platform layer
rather than the application layer. Service meshes are implemented by adding
<a href=#sidecar-proxy>sidecar proxies</a> that intercept all traffic between
applications. The resulting set of proxies forms the service mesh
<a href=#data-plane>data plane</a> and is managed by the service mesh
<a href=#control-plane>control plane</a>. The proxies funnel all communication between
services and are the vehicle through which service mesh features are introduced.</p><h2 id=sidecar-proxy class=anchor>Sidecar Proxy
<a href=#sidecar-proxy class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>A sidecar proxy is a proxy that is deployed alongside the applications in the
mesh. (In Kubernetes, as a container within the application&rsquo;s pod.) The sidecar
proxy intercepts network calls to and from the applications and is responsible
for implementing any <a href=#control-plane>control plane</a>’s logic or rules.
Collectively, the sidecar proxies form the service mesh&rsquo;s
<a href=#data-plane>data plane</a>. Linkerd uses a Rust-based &ldquo;micro-proxy&rdquo; called
Linkerd2-proxy that is specifically designed for the service mesh use case.
Linkerd2-proxy is significantly lighter and easier to operate than
general-purpose proxies such as Envoy or NGINX. See
<a href=/2020/12/03/why-linkerd-doesnt-use-envoy/>Why Linkerd Doesn&rsquo;t Use Envoy</a> for
more.</p><h2 id=success-rate class=anchor>Success rate
<a href=#success-rate class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>Success rate refers to the percentage of requests that our application responds
to successfully. For HTTP traffic, for example, this is measured as the
proportion of 2xx or 4xx responses over total responses. (Note that, in this
context, 4xx is considered a successful response—the application performed its
jobs—whereas 5xx responses are considered unsuccessful—the application failed to
respond to the request). A high success rate indicates that an application is
behaving correctly.</p></div></div></div></div></div></main><footer class=main-footer><div class=main-footer__top><div class="main-footer__container container"><div class=main-footer__info><p><img src=/logos/linkerd.png alt=Linkerd></p><p>Linkerd was originally created by <a href=https://buoyant.io/ target=_blank rel=noopener>Buoyant</a></p><p>View <a href=https://github.com/linkerd/linkerd/wiki/Linkerd-code-of-conduct target=_blank rel=noopener>Code of Conduct</a></p></div><div class=main-footer__links><div class=main-footer__community><h4>Community</h4><ul><li><a href=https://github.com/linkerd/linkerd2 target=_blank rel=noopener>GitHub</a></li><li><a href=https://slack.linkerd.io target=_blank rel=noopener>Slack</a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener>Linkerd Forum</a></li></ul></div><div class=main-footer__follow><h4>Follow</h4><ul><li><a href=https://www.linkedin.com/company/linkerd/ target=_blank rel=noopener>Linkedin</a></li><li><a href=https://www.youtube.com/buoyantio target=_blank rel=noopener>YouTube</a></li><li><a href=https://twitter.com/linkerd target=_blank rel=noopener>Twitter</a></li></ul></div></div></div></div><div class=main-footer__bottom><div class="main-footer__container container"><p><a href=https://github.com/linkerd/website/tree/main/linkerd.io/content target=_blank rel=noopener>Edit This Site</a></p><p>Copyright © 2024 Linkerd Authors. All rights reserved.</p></div></div></footer></body></html>