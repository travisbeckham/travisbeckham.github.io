<!doctype html><html lang=en><head><meta charset=utf-8><title>Multi-cluster communication | Linkerd</title>
<link rel="shortcut icon" href=/favicon.png><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Allow Linkerd to manage cross-cluster communication."><meta property="og:url" content="https://travisbeckham.github.io/2.15/tasks/multicluster/"><meta property="og:site_name" content="Linkerd"><meta property="og:title" content="Multi-cluster communication"><meta property="og:description" content="Allow Linkerd to manage cross-cluster communication."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="2.15"><meta property="og:image" content="https://travisbeckham.github.io/logos/linkerd.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://travisbeckham.github.io/logos/linkerd.png"><meta name=twitter:title content="Multi-cluster communication"><meta name=twitter:description content="Allow Linkerd to manage cross-cluster communication."><meta name=twitter:site content="@Linkerd"><link rel=canonical href=https://travisbeckham.github.io/2.15/tasks/multicluster/><link rel=stylesheet href=/css/main.css><script src=/js/main.js></script><script async defer src=https://buttons.github.io/buttons.js></script></head><body><header class=main-header><div class=main-header__container><div class=main-header__logo><a href=/><img src=/logos/linkerd.png alt=Linkerd></a></div><input class=main-header__toggle-checkbox type=checkbox id=main-header-toggle>
<label class=main-header__toggle for=main-header-toggle><span class=main-header__toggle-icon><span class=main-header__toggle-icon--open><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3 6H21V8H3V6m0 5H21v2H3V11m0 5H21v2H3V16z"/></svg>
</span><span class=main-header__toggle-icon--close><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg></span></span></label><div class=main-header__nav><nav class=main-nav><ul class=main-nav__menu><li class=main-nav__menu--selected><a href=/docs>Docs</a></li><li><a href=#>Community<svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M7.41 8.58 12 13.17l4.59-4.59L18 10l-6 6-6-6L7.41 8.58z"/></svg></a><ul><li><a href=/community/get-involved/>Get Involved</a></li><li><a href=/community/adopters/>Adopters</a></li><li><a href=/community/ambassadors/>Linkerd Ambassadors</a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener>Buoyant's Linkerd Forum</a></li></ul></li><li><a href=/blog/>Blog</a></li><li><a href=/faq/>FAQ</a></li><li><a href=/enterprise/>Enterprise</a></li></ul><div class=main-nav__search><form action=/search method=get><div class="search-input search-input--sm"><svg class="icon" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5.0 0116 9.5c0 1.61-.59 3.09-1.56 4.23L14.71 14H15.5l5 5L19 20.5l-5-5V14.71L13.73 14.44C12.59 15.41 11.11 16 9.5 16A6.5 6.5.0 013 9.5 6.5 6.5.0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
<input type=text name=q placeholder=Search></div></form></div><div class=main-nav__github><a class=github-button href=https://github.com/linkerd/linkerd2 data-icon=octicon-star data-size=large data-show-count=true aria-label="Star linkerd/linkerd2 on GitHub">Star</a></div><div class=main-nav__forum><a href=https://linkerd.buoyant.io class="button button--primary button--sm" target=_blank rel=noopener>Join Forum</a></div></nav></div></div></header><div class=main-announcement>Service Mesh 101: Get Service Mesh-Certified
<span class=main-announcement__link><a href=https://buoyant.io/courses/service-mesh-101 target=_blank rel=noopener>Enroll now</a></span></div><main class=main-content><div class="alert alert--warning alert--condensed alert--center docs__deprecated-alert"><div class=alert__content>You are viewing docs for an older version of Linkerd.
<a href=/2.16/>View the latest docs</a>.</div></div><div class=docs><div class=docs__container><div class=docs__sidebar><div class=docs__nav><div class=docs__versions><select onchange="window.location.href=this.value"><option value=/2-edge/>Linkerd edge</option><option value=/2.16/>Linkerd 2.16</option><option value=/2.15/ selected>Linkerd 2.15</option><option value=/2.14/>Linkerd 2.14</option><option value=/2.13/>Linkerd 2.13</option><option value=/2.12/>Linkerd 2.12</option><option value=/2.11/>Linkerd 2.11</option><option value=/2.10/>Linkerd 2.10</option></select></div><nav><ul><li><a href=/2.15/overview/>Overview</a></li><li><a href=/2.15/getting-started/>Getting Started</a></li><li><a href=/2.15/features/>Features
</a><input class=toggle__input type=checkbox id=toggle-9502176e66310dde847fdf0e0179df48>
<label class=toggle__label for=toggle-9502176e66310dde847fdf0e0179df48><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.15/features/http-grpc/>HTTP, HTTP/2, and gRPC Proxying</a></li><li><a href=/2.15/features/protocol-detection/>TCP Proxying and Protocol Detection</a></li><li><a href=/2.15/features/retries-and-timeouts/>Retries and Timeouts</a></li><li><a href=/2.15/features/automatic-mtls/>Automatic mTLS</a></li><li><a href=/2.15/features/ingress/>Ingress</a></li><li><a href=/2.15/features/telemetry/>Telemetry and Monitoring</a></li><li><a href=/2.15/features/load-balancing/>Load Balancing</a></li><li><a href=/2.15/features/server-policy/>Authorization Policy</a></li><li><a href=/2.15/features/proxy-injection/>Automatic Proxy Injection</a></li><li><a href=/2.15/features/cni/>CNI Plugin</a></li><li><a href=/2.15/features/dashboard/>Dashboard and on-cluster metrics stack</a></li><li><a href=/2.15/features/distributed-tracing/>Distributed Tracing</a></li><li><a href=/2.15/features/request-routing/>Dynamic Request Routing</a></li><li><a href=/2.15/features/fault-injection/>Fault Injection</a></li><li><a href=/2.15/features/ha/>High Availability</a></li><li><a href=/2.15/features/access-logging/>HTTP Access Logging</a></li><li><a href=/2.15/features/httproute/>HTTPRoutes</a></li><li><a href=/2.15/features/nft/>Iptables-nft Support</a></li><li><a href=/2.15/features/multicluster/>Multi-cluster communication</a></li><li><a href=/2.15/features/non-kubernetes-workloads/>Non-Kubernetes workloads (mesh expansion)</a></li><li><a href=/2.15/features/service-profiles/>Service Profiles</a></li><li><a href=/2.15/features/traffic-split/>Traffic Split (canaries, blue/green deploys)</a></li></ul></li><li class=docs__nav--selected><a href=/2.15/tasks/>Tasks
</a><input class=toggle__input type=checkbox id=toggle-d3491daa3401b9d2bd77587482630419 checked>
<label class=toggle__label for=toggle-d3491daa3401b9d2bd77587482630419><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.15/tasks/adding-non-kubernetes-workloads/>Adding non-Kubernetes workloads to your mesh</a></li><li><a href=/2.15/tasks/adding-your-service/>Adding your services to Linkerd</a></li><li><a href=/2.15/tasks/automatic-failover/>Automatic Multicluster Failover</a></li><li><a href=/2.15/tasks/automatically-rotating-control-plane-tls-credentials/>Automatically Rotating Control Plane TLS Credentials</a></li><li><a href=/2.15/tasks/automatically-rotating-webhook-tls-credentials/>Automatically Rotating Webhook TLS Credentials</a></li><li><a href=/2.15/tasks/external-prometheus/>Bringing your own Prometheus</a></li><li><a href=/2.15/tasks/circuit-breakers/>Circuit Breakers</a></li><li><a href=/2.15/tasks/configuring-dynamic-request-routing/>Configuring Dynamic Request Routing</a></li><li><a href=/2.15/tasks/configuring-per-route-policy/>Configuring Per-Route Authorization Policy</a></li><li><a href=/2.15/tasks/configuring-proxy-concurrency/>Configuring Proxy Concurrency</a></li><li><a href=/2.15/tasks/configuring-proxy-discovery-cache/>Configuring Proxy Discovery Cache</a></li><li><a href=/2.15/tasks/configuring-retries/>Configuring Retries</a></li><li><a href=/2.15/tasks/configuring-timeouts/>Configuring Timeouts</a></li><li><a href=/2.15/tasks/using-debug-endpoints/>Control Plane Debug Endpoints</a></li><li><a href=/2.15/tasks/customize-install/>Customizing Linkerd's Configuration with Kustomize</a></li><li><a href=/2.15/tasks/debugging-502s/>Debugging 502s</a></li><li><a href=/2.15/tasks/debugging-your-service/>Debugging gRPC applications with request tracing</a></li><li><a href=/2.15/tasks/books/>Debugging HTTP applications with per-route metrics</a></li><li><a href=/2.15/tasks/distributed-tracing/>Distributed tracing with Linkerd</a></li><li><a href=/2.15/tasks/exporting-metrics/>Exporting Metrics</a></li><li><a href=/2.15/tasks/exposing-dashboard/>Exposing the Dashboard</a></li><li><a href=/2.15/tasks/generate-certificates/>Generating your own mTLS root certificates</a></li><li><a href=/2.15/tasks/getting-per-route-metrics/>Getting Per-Route Metrics</a></li><li><a href=/2.15/tasks/linkerd-smi/>Getting started with Linkerd SMI extension</a></li><li><a href=/2.15/tasks/graceful-shutdown/>Graceful Pod Shutdown</a></li><li><a href=/2.15/tasks/grafana/>Grafana</a></li><li><a href=/2.15/tasks/using-ingress/>Handling ingress traffic</a></li><li><a href=/2.15/tasks/fault-injection/>Injecting Faults</a></li><li><a href=/2.15/tasks/install/>Installing Linkerd</a></li><li><a href=/2.15/tasks/install-helm/>Installing Linkerd with Helm</a></li><li><a href=/2.15/tasks/installing-multicluster/>Installing Multi-cluster Components</a></li><li><a href=/2.15/tasks/using-psp/>Linkerd and Pod Security Policies (PSP)</a></li><li><a href=/2.15/tasks/manually-rotating-control-plane-tls-credentials/>Manually Rotating Control Plane TLS Credentials</a></li><li><a href=/2.15/tasks/modifying-proxy-log-level/>Modifying the Proxy Log Level</a></li><li class=docs__nav--selected><a href=/2.15/tasks/multicluster/>Multi-cluster communication</a></li><li><a href=/2.15/tasks/multicluster-using-statefulsets/>Multi-cluster communication with StatefulSets</a></li><li><a href=/2.15/tasks/pod-to-pod-multicluster/>Pod-to-Pod Multi-cluster communication</a></li><li><a href=/2.15/tasks/flagger/>Progressive Delivery</a></li><li><a href=/2.15/tasks/replacing_expired_certificates/>Replacing expired certificates</a></li><li><a href=/2.15/tasks/restricting-access/>Restricting Access To Services</a></li><li><a href=/2.15/tasks/rotating_webhooks_certificates/>Rotating webhooks certificates</a></li><li><a href=/2.15/tasks/securing-linkerd-tap/>Securing Linkerd Tap</a></li><li><a href=/2.15/tasks/setting-up-service-profiles/>Setting Up Service Profiles</a></li><li><a href=/2.15/tasks/traffic-shifting/>Traffic Shifting</a></li><li><a href=/2.15/tasks/troubleshooting/>Troubleshooting</a></li><li><a href=/2.15/tasks/uninstall/>Uninstalling Linkerd</a></li><li><a href=/2.15/tasks/uninstall-multicluster/>Uninstalling Multicluster</a></li><li><a href=/2.15/tasks/upgrade/>Upgrading Linkerd</a></li><li><a href=/2.15/tasks/using-custom-domain/>Using a Custom Cluster Domain</a></li><li><a href=/2.15/tasks/extensions/>Using extensions</a></li><li><a href=/2.15/tasks/gitops/>Using GitOps with Linkerd with Argo CD</a></li><li><a href=/2.15/tasks/using-the-debug-container/>Using the Debug Sidecar</a></li><li><a href=/2.15/tasks/validating-your-traffic/>Validating your mTLS traffic</a></li></ul></li><li><a href=/2.15/reference/>Reference
</a><input class=toggle__input type=checkbox id=toggle-6c1ed631a095b70fc00aeb5c380a1fe3>
<label class=toggle__label for=toggle-6c1ed631a095b70fc00aeb5c380a1fe3><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.15/reference/architecture/>Architecture</a></li><li><a href=/2.15/reference/authorization-policy/>Authorization Policy</a></li><li><a href=/2.15/reference/circuit-breaking/>Circuit Breaking</a></li><li><a href=/2.15/reference/cli/>CLI
</a><input class=toggle__input type=checkbox id=toggle-bc91c7f240985a01728bf733237a9d0d>
<label class=toggle__label for=toggle-bc91c7f240985a01728bf733237a9d0d><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.15/reference/cli/authz/>authz</a></li><li><a href=/2.15/reference/cli/check/>check</a></li><li><a href=/2.15/reference/cli/completion/>completion</a></li><li><a href=/2.15/reference/cli/diagnostics/>diagnostics</a></li><li><a href=/2.15/reference/cli/identity/>identity</a></li><li><a href=/2.15/reference/cli/inject/>inject</a></li><li><a href=/2.15/reference/cli/install/>install</a></li><li><a href=/2.15/reference/cli/install-cni/>install-cni</a></li><li><a href=/2.15/reference/cli/jaeger/>jaeger</a></li><li><a href=/2.15/reference/cli/multicluster/>multicluster</a></li><li><a href=/2.15/reference/cli/profile/>profile</a></li><li><a href=/2.15/reference/cli/prune/>prune</a></li><li><a href=/2.15/reference/cli/uninject/>uninject</a></li><li><a href=/2.15/reference/cli/uninstall/>uninstall</a></li><li><a href=/2.15/reference/cli/upgrade/>upgrade</a></li><li><a href=/2.15/reference/cli/version/>version</a></li><li><a href=/2.15/reference/cli/viz/>viz</a></li></ul></li><li><a href=/2.15/reference/cluster-configuration/>Cluster Configuration</a></li><li><a href=/2.15/reference/extension-list/>Extensions List</a></li><li><a href=/2.15/reference/external-workload/>ExternalWorkload</a></li><li><a href=/2.15/reference/httproute/>HTTPRoute</a></li><li><a href=/2.15/reference/iptables/>IPTables Reference</a></li><li><a href=/2.15/reference/multicluster/>Multi-cluster communication</a></li><li><a href=/2.15/reference/proxy-configuration/>Proxy Configuration</a></li><li><a href=/2.15/reference/proxy-log-level/>Proxy Log Level</a></li><li><a href=/2.15/reference/proxy-metrics/>Proxy Metrics</a></li><li><a href=/2.15/reference/service-profiles/>Service Profiles</a></li><li><a href=/2.15/reference/k8s-versions/>Supported Kubernetes Versions</a></li></ul></li><li><a href=/2.15/common-errors/>Common Errors
</a><input class=toggle__input type=checkbox id=toggle-70fc38683e3d1aadd6c9fc9f3235e04b>
<label class=toggle__label for=toggle-70fc38683e3d1aadd6c9fc9f3235e04b><svg class="icon icon--secondary" viewBox="0 0 24 24"><path d="M8.59 16.58 13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg></label><ul class=toggle__target><li><a href=/2.15/common-errors/failfast/>Failfast</a></li><li><a href=/2.15/common-errors/http-502/>HTTP 502 Errors</a></li><li><a href=/2.15/common-errors/http-503-504/>HTTP 503 and 504 Errors</a></li><li><a href=/2.15/common-errors/protocol-detection/>Protocol Detection Errors</a></li></ul></li></ul><ul><li><a href=/what-is-a-service-mesh/>What is a service mesh?</a></li><li><a href=/faq/>Frequently Asked Questions</a></li><li><a href=/releases/>Releases and Versions</a></li><li><a href=/design-principles/>Design Principles</a></li><li><a href=/going-to-production/>Going to Production</a></li><li><a href=/service-mesh-glossary/>Service Mesh Glossary</a></li></ul></nav><div class=docs__community><ul><li><a href=https://github.com/linkerd/linkerd2 target=_blank rel=noopener><img src=/logos/github.svg alt=GitHub class=img></a></li><li><a href=https://slack.linkerd.io target=_blank rel=noopener><img src=/logos/slack.svg alt=Slack class=img></a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener><img src=/logos/forum.png alt="Linkerd Forum" class=img></a></li></ul></div></div></div><div class=docs__main><div class=docs__body><div class=docs__header><h1>Multi-cluster communication</h1></div><div class="docs__content prose"><p>This guide will walk you through installing and configuring Linkerd so that two
clusters can talk to services hosted on both. There are a lot of moving parts
and concepts here, so it is valuable to read through our
<a href=../../features/multicluster/>introduction</a> that explains how this works beneath
the hood. By the end of this guide, you will understand how to split traffic
between services that live on different clusters.</p><p>At a high level, you will:</p><ol><li><a href=#install-linkerd>Install Linkerd and Linkerd Viz</a> on two clusters with a
shared trust anchor.</li><li><a href=#preparing-your-cluster>Prepare</a> the clusters.</li><li><a href=#linking-the-clusters>Link</a> the clusters.</li><li><a href=#installing-the-test-services>Install</a> the demo.</li><li><a href=#exporting-the-services>Export</a> the demo services, to control visibility.</li><li><a href=#visibility>Gain visibility</a> in your linked clusters.</li><li><a href=#security>Verify</a> the security of your clusters.</li><li><a href=#traffic-splitting>Split traffic</a> from pods on the source cluster (<code>west</code>)
to the target cluster (<code>east</code>)</li></ol><h2 id=prerequisites class=anchor>Prerequisites
<a href=#prerequisites class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><ul><li>Two clusters. We will refer to them as <code>east</code> and <code>west</code> in this guide. Follow
along with the
<a href=/2020/02/25/multicluster-kubernetes-with-service-mirroring/>blog post</a> as
you walk through this guide! The easiest way to do this for development is
running a <a href=https://kind.sigs.k8s.io/docs/user/quick-start/ target=_blank rel=noopener>kind</a> or
<a href=https://github.com/rancher/k3d#usage target=_blank rel=noopener>k3d</a> cluster locally on your laptop and
one remotely on a cloud provider, such as
<a href=https://azure.microsoft.com/en-us/services/kubernetes-service/ target=_blank rel=noopener>AKS</a>.</li><li>Each of these clusters should be configured as <code>kubectl</code>
<a href=https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/ target=_blank rel=noopener>contexts</a>.
We&rsquo;d recommend you use the names <code>east</code> and <code>west</code> so that you can follow
along with this guide. It is easy to
<a href=https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-em-rename-context-em- target=_blank rel=noopener>rename contexts</a>
with <code>kubectl</code>, so don&rsquo;t feel like you need to keep it all named this way
forever.</li><li>Elevated privileges on both clusters. We&rsquo;ll be creating service accounts and
granting extended privileges, so you&rsquo;ll need to be able to do that on your
test clusters.</li><li>Support for services of type <code>LoadBalancer</code> in the <code>east</code> cluster. Check out
the documentation for your cluster provider or take a look at
<a href=https://blog.alexellis.io/ingress-for-your-local-kubernetes-cluster/ target=_blank rel=noopener>inlets</a>.
This is what the <code>west</code> cluster will use to communicate with <code>east</code> via the
gateway.</li></ul><h2 id=install-linkerd-and-linkerd-viz class=anchor>Install Linkerd and Linkerd Viz
<a href=#install-linkerd-and-linkerd-viz class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><figure><img alt=install class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/install.svg><figcaption>Two Clusters</figcaption></figure><p>Linkerd requires a shared
<a href=../generate-certificates/#trust-anchor-certificate>trust anchor</a>
to exist between the installations in all clusters that communicate with each
other. This is used to encrypt the traffic between clusters and authorize
requests that reach the gateway so that your cluster is not open to the public
internet. Instead of letting <code>linkerd</code> generate everything, we&rsquo;ll need to
generate the credentials and use them as configuration for the <code>install</code>
command.</p><p>We like to use the <a href=https://smallstep.com/cli/ target=_blank rel=noopener>step</a> CLI to generate these
certificates. If you prefer <code>openssl</code> instead, feel free to use that! To
generate the trust anchor with step, you can run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>step certificate create root.linkerd.cluster.local root.crt root.key <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --profile root-ca --no-password --insecure
</span></span></code></pre></div><p>This certificate will form the common base of trust between all your clusters.
Each proxy will get a copy of this certificate and use it to validate the
certificates that it receives from peers as part of the mTLS handshake. With a
common base of trust, we now need to generate a certificate that can be used in
each cluster to issue certificates to the proxies. If you&rsquo;d like to get a deeper
picture into how this all works, check out the
<a href=../../features/automatic-mtls/#how-does-it-work>deep dive</a>.</p><p>The trust anchor that we&rsquo;ve generated is a self-signed certificate which can be
used to create new certificates (a certificate authority). To generate the
<a href=../generate-certificates/#issuer-certificate-and-key>issuer credentials</a>
using the trust anchor, run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>step certificate create identity.linkerd.cluster.local issuer.crt issuer.key <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --profile intermediate-ca --not-after 8760h --no-password --insecure <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --ca root.crt --ca-key root.key
</span></span></code></pre></div><p>An <code>identity</code> service in your cluster will use the certificate and key that you
generated here to generate the certificates that each individual proxy uses.
While we will be using the same issuer credentials on each cluster for this
guide, it is a good idea to have separate ones for each cluster. Read through
the <a href=../generate-certificates/>certificate documentation</a> for more
details.</p><p>With a valid trust anchor and issuer credentials, we can install Linkerd on your
<code>west</code> and <code>east</code> clusters now.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8b949e;font-style:italic># first, install the Linkerd CRDs in both clusters</span>
</span></span><span style=display:flex><span>linkerd install --crds <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  | tee <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    &gt;<span style=color:#ff7b72;font-weight:700>(</span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west apply -f -<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    &gt;<span style=color:#ff7b72;font-weight:700>(</span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>east apply -f -<span style=color:#ff7b72;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># then install the Linkerd control plane in both clusters</span>
</span></span><span style=display:flex><span>linkerd install <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --identity-trust-anchors-file root.crt <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --identity-issuer-certificate-file issuer.crt <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --identity-issuer-key-file issuer.key <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  | tee <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    &gt;<span style=color:#ff7b72;font-weight:700>(</span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west apply -f -<span style=color:#ff7b72;font-weight:700>)</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    &gt;<span style=color:#ff7b72;font-weight:700>(</span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>east apply -f -<span style=color:#ff7b72;font-weight:700>)</span>
</span></span></code></pre></div><p>And then Linkerd Viz:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff7b72>for</span> ctx in west east; <span style=color:#ff7b72>do</span>
</span></span><span style=display:flex><span>  linkerd --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> viz install | <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> apply -f - <span style=color:#ff7b72;font-weight:700>||</span> break
</span></span><span style=display:flex><span><span style=color:#ff7b72>done</span>
</span></span></code></pre></div><p>The output from <code>install</code> will get applied to each cluster and come up! You can
verify that everything has come up successfully with <code>check</code>.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff7b72>for</span> ctx in west east; <span style=color:#ff7b72>do</span>
</span></span><span style=display:flex><span>  echo <span style=color:#a5d6ff>&#34;Checking cluster: </span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff> .........&#34;</span>
</span></span><span style=display:flex><span>  linkerd --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> check <span style=color:#ff7b72;font-weight:700>||</span> break
</span></span><span style=display:flex><span>  echo <span style=color:#a5d6ff>&#34;-------------&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>done</span>
</span></span></code></pre></div><h2 id=preparing-your-cluster class=anchor>Preparing your cluster
<a href=#preparing-your-cluster class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><figure><img alt=preparation class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/prep-overview.svg><figcaption>Preparation</figcaption></figure><p>In order to route traffic between clusters, Linkerd leverages Kubernetes
services so that your application code does not need to change and there is
nothing new to learn. This requires a gateway component that routes incoming
requests to the correct internal service. The gateway will be exposed to the
public internet via a <code>Service</code> of type <code>LoadBalancer</code>. Only requests verified
through Linkerd&rsquo;s mTLS (with a shared trust anchor) will be allowed through this
gateway. If you&rsquo;re interested, we go into more detail as to why this is
important in <a href=/2020/02/17/architecting-for-multicluster-kubernetes/#requirement-i-support-hierarchical-networks>architecting for multicluster Kubernetes</a>.</p><p>To install the multicluster components on both <code>west</code> and <code>east</code>, you can run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff7b72>for</span> ctx in west east; <span style=color:#ff7b72>do</span>
</span></span><span style=display:flex><span>  echo <span style=color:#a5d6ff>&#34;Installing on cluster: </span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff> .........&#34;</span>
</span></span><span style=display:flex><span>  linkerd --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> multicluster install | <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> apply -f - <span style=color:#ff7b72;font-weight:700>||</span> break
</span></span><span style=display:flex><span>  echo <span style=color:#a5d6ff>&#34;-------------&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>done</span>
</span></span></code></pre></div><figure><img alt=install class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/components.svg><figcaption>Components</figcaption></figure><p>Installed into the <code>linkerd-multicluster</code> namespace, the gateway is a simple
<a href=https://github.com/linkerd/linkerd2/blob/main/multicluster/charts/linkerd-multicluster/templates/gateway.yaml#L3 target=_blank rel=noopener>pause container</a>
which has been injected with the Linkerd proxy. On the inbound side, Linkerd
takes care of validating that the connection uses a TLS certificate that is part
of the trust anchor, then handles the outbound connection. At this point, the
Linkerd proxy is operating like any other in the data plane and forwards the
requests to the correct service. Make sure the gateway comes up successfully by
running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff7b72>for</span> ctx in west east; <span style=color:#ff7b72>do</span>
</span></span><span style=display:flex><span>  echo <span style=color:#a5d6ff>&#34;Checking gateway on cluster: </span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff> .........&#34;</span>
</span></span><span style=display:flex><span>  kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> -n linkerd-multicluster <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    rollout status deploy/linkerd-gateway <span style=color:#ff7b72;font-weight:700>||</span> break
</span></span><span style=display:flex><span>  echo <span style=color:#a5d6ff>&#34;-------------&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>done</span>
</span></span></code></pre></div><p>Double check that the load balancer was able to allocate a public IP address by
running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff7b72>for</span> ctx in west east; <span style=color:#ff7b72>do</span>
</span></span><span style=display:flex><span>  printf <span style=color:#a5d6ff>&#34;Checking cluster: </span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff> .........&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>while</span> <span style=color:#ff7b72;font-weight:700>[</span> <span style=color:#a5d6ff>&#34;</span><span style=color:#ff7b72>$(</span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> -n linkerd-multicluster get service -o <span style=color:#a5d6ff>&#39;custom-columns=:.status.loadBalancer.ingress[0].ip&#39;</span> --no-headers<span style=color:#ff7b72>)</span><span style=color:#a5d6ff>&#34;</span> <span style=color:#ff7b72;font-weight:700>=</span> <span style=color:#a5d6ff>&#34;&lt;none&gt;&#34;</span> <span style=color:#ff7b72;font-weight:700>]</span>; <span style=color:#ff7b72>do</span>
</span></span><span style=display:flex><span>      printf <span style=color:#a5d6ff>&#39;.&#39;</span>
</span></span><span style=display:flex><span>      sleep <span style=color:#a5d6ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#ff7b72>done</span>
</span></span><span style=display:flex><span>  printf <span style=color:#a5d6ff>&#34;\n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>done</span>
</span></span></code></pre></div><p>Every cluster is now running the multicluster control plane and ready to start
mirroring services. We&rsquo;ll want to link the clusters together now!</p><h2 id=linking-the-clusters class=anchor>Linking the clusters
<a href=#linking-the-clusters class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><figure><img alt=link-clusters class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/link-flow.svg><figcaption>Link</figcaption></figure><p>For <code>west</code> to mirror services from <code>east</code>, the <code>west</code> cluster needs to have
credentials so that it can watch for services in <code>east</code> to be exported. You&rsquo;d
not want anyone to be able to introspect what&rsquo;s running on your cluster after
all! The credentials consist of a service account to authenticate the service
mirror as well as a <code>ClusterRole</code> and <code>ClusterRoleBinding</code> to allow watching
services. In total, the service mirror component uses these credentials to watch
services on <code>east</code> or the target cluster and add/remove them from itself
(<code>west</code>). There is a default set added as part of
<code>linkerd multicluster install</code>, but if you would like to have separate
credentials for every cluster you can run <code>linkerd multicluster allow</code>.</p><p>The next step is to link <code>west</code> to <code>east</code>. This will create a credentials
secret, a Link resource, and a service-mirror controller. The credentials secret
contains a kubeconfig which can be used to access the target (<code>east</code>) cluster&rsquo;s
Kubernetes API. The Link resource is custom resource that configures service
mirroring and contains things such as the gateway address, gateway identity,
and the label selector to use when determining which services to mirror. The
service-mirror controller uses the Link and the secret to find services on
the target cluster that match the given label selector and copy them into
the source (local) cluster.</p><p>To link the <code>west</code> cluster to the <code>east</code> one, run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#ff7b72;font-weight:700>=</span>east multicluster link --cluster-name east |
</span></span><span style=display:flex><span>  kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west apply -f -
</span></span></code></pre></div><p>Linkerd will look at your current <code>east</code> context, extract the <code>cluster</code>
configuration which contains the server location as well as the CA bundle. It
will then fetch the <code>ServiceAccount</code> token and merge these pieces of
configuration into a kubeconfig that is a secret.</p><p>Running <code>check</code> again will make sure that the service mirror has discovered this
secret and can reach <code>east</code>.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#ff7b72;font-weight:700>=</span>west multicluster check
</span></span></code></pre></div><p>Additionally, the <code>east</code> gateway should now show up in the list:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#ff7b72;font-weight:700>=</span>west multicluster gateways
</span></span></code></pre></div><div class="alert alert--info alert--callout"><div class=alert__title><svg class="icon icon--current" viewBox="0 0 24 24"><path d="M13 9H11V7h2m0 10H11V11h2M12 2A10 10 0 002 12 10 10 0 0012 22 10 10 0 0022 12 10 10 0 0012 2z"/></svg><h4>Note</h4></div><div class=alert__content><code>link</code> assumes that the two clusters will connect to each other
with the same configuration as you&rsquo;re using locally. If this is not the case,
you&rsquo;ll want to use the <code>--api-server-address</code> flag for <code>link</code>.</div></div><h2 id=installing-the-test-services class=anchor>Installing the test services
<a href=#installing-the-test-services class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><figure><img alt=test-services class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/example-topology.svg><figcaption>Topology</figcaption></figure><p>It is time to test this all out! The first step is to add some services that we
can mirror. To add these to both clusters, you can run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff7b72>for</span> ctx in west east; <span style=color:#ff7b72>do</span>
</span></span><span style=display:flex><span>  echo <span style=color:#a5d6ff>&#34;Adding test services on cluster: </span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff> .........&#34;</span>
</span></span><span style=display:flex><span>  kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> apply <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -n test -k <span style=color:#a5d6ff>&#34;github.com/linkerd/website/multicluster/</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span><span style=color:#a5d6ff>/&#34;</span>
</span></span><span style=display:flex><span>  kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> -n test <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    rollout status deploy/podinfo <span style=color:#ff7b72;font-weight:700>||</span> break
</span></span><span style=display:flex><span>  echo <span style=color:#a5d6ff>&#34;-------------&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>done</span>
</span></span></code></pre></div><p>You&rsquo;ll now have a <code>test</code> namespace running two deployments in each cluster -
frontend and podinfo. <code>podinfo</code> has been configured slightly differently in each
cluster with a different name and color so that we can tell where requests are
going.</p><p>To see what it looks like from the <code>west</code> cluster right now, you can run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test port-forward svc/frontend <span style=color:#a5d6ff>8080</span>
</span></span></code></pre></div><figure><img alt=west-podinfo class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/west-podinfo.gif><figcaption>West Podinfo</figcaption></figure><p>With the podinfo landing page available at
<a href=http://localhost:8080 target=_blank rel=noopener>http://localhost:8080</a>, you can see how it looks in the
<code>west</code> cluster right now. Alternatively, running <code>curl http://localhost:8080</code>
will return a JSON response that looks something like:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;hostname&#34;</span>: <span style=color:#a5d6ff>&#34;podinfo-5c8cf55777-zbfls&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;version&#34;</span>: <span style=color:#a5d6ff>&#34;4.0.2&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;revision&#34;</span>: <span style=color:#a5d6ff>&#34;b4138fdb4dce7b34b6fc46069f70bb295aa8963c&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;color&#34;</span>: <span style=color:#a5d6ff>&#34;#6c757d&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;logo&#34;</span>: <span style=color:#a5d6ff>&#34;https://raw.githubusercontent.com/stefanprodan/podinfo/gh-pages/cuddle_clap.gif&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;message&#34;</span>: <span style=color:#a5d6ff>&#34;greetings from west&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;goos&#34;</span>: <span style=color:#a5d6ff>&#34;linux&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;goarch&#34;</span>: <span style=color:#a5d6ff>&#34;amd64&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;runtime&#34;</span>: <span style=color:#a5d6ff>&#34;go1.14.3&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;num_goroutine&#34;</span>: <span style=color:#a5d6ff>&#34;8&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#7ee787>&#34;num_cpu&#34;</span>: <span style=color:#a5d6ff>&#34;4&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice that the <code>message</code> references the <code>west</code> cluster name.</p><h2 id=exporting-the-services class=anchor>Exporting the services
<a href=#exporting-the-services class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>To make sure sensitive services are not mirrored and cluster performance is
impacted by the creation or deletion of services, we require that services be
explicitly exported. For the purposes of this guide, we will be exporting the
<code>podinfo</code> service from the <code>east</code> cluster to the <code>west</code> cluster. To do this, we
must first export the <code>podinfo</code> service in the <code>east</code> cluster. You can do this
by adding the <code>mirror.linkerd.io/exported</code> label:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>east label svc -n test podinfo mirror.linkerd.io/exported<span style=color:#ff7b72;font-weight:700>=</span>true
</span></span></code></pre></div><div class="alert alert--info alert--callout"><div class=alert__title><svg class="icon icon--current" viewBox="0 0 24 24"><path d="M13 9H11V7h2m0 10H11V11h2M12 2A10 10 0 002 12 10 10 0 0012 22 10 10 0 0022 12 10 10 0 0012 2z"/></svg><h4>Note</h4></div><div class=alert__content>You can configure a different label selector by using the
<code>--selector</code> flag on the <code>linkerd multicluster link</code> command or by editting
the Link resource created by the <code>linkerd multicluster link</code> command.</div></div><p>Check out the service that was just created by the service mirror controller!</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test get svc podinfo-east
</span></span></code></pre></div><p>From the
<a href=https://linkerd.io/2020/02/25/multicluster-kubernetes-with-service-mirroring/#step-2-endpoint-juggling target=_blank rel=noopener>architecture</a>,
you&rsquo;ll remember that the service mirror component is doing more than just moving
services over. It is also managing the endpoints on the mirrored service. To
verify that is setup correctly, you can check the endpoints in <code>west</code> and verify
that they match the gateway&rsquo;s public IP address in <code>east</code>.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test get endpoints podinfo-east <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  -o <span style=color:#a5d6ff>&#39;custom-columns=ENDPOINT_IP:.subsets[*].addresses[*].ip&#39;</span>
</span></span><span style=display:flex><span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>east -n linkerd-multicluster get svc linkerd-gateway <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  -o <span style=color:#a5d6ff>&#34;custom-columns=GATEWAY_IP:.status.loadBalancer.ingress[*].ip&#34;</span>
</span></span></code></pre></div><p>At this point, we can hit the <code>podinfo</code> service in <code>east</code> from the <code>west</code>
cluster. This requires the client to be meshed, so let&rsquo;s run <code>curl</code> from within
the frontend pod:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test exec -c nginx -it <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  <span style=color:#ff7b72>$(</span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test get po -l <span style=color:#79c0ff>app</span><span style=color:#ff7b72;font-weight:700>=</span>frontend <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    --no-headers -o custom-columns<span style=color:#ff7b72;font-weight:700>=</span>:.metadata.name<span style=color:#ff7b72>)</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  -- /bin/sh -c <span style=color:#a5d6ff>&#34;apk add curl &amp;&amp; curl http://podinfo-east:9898&#34;</span>
</span></span></code></pre></div><p>You&rsquo;ll see the <code>greeting from east</code> message! Requests from the <code>frontend</code> pod
running in <code>west</code> are being transparently forwarded to <code>east</code>. Assuming that
you&rsquo;re still port forwarding from the previous step, you can also reach this
with <code>curl http://localhost:8080/east</code>. Make that call a couple times and
you&rsquo;ll be able to get metrics from <code>linkerd viz stat</code> as well.</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test viz stat --from deploy/frontend svc
</span></span></code></pre></div><p>We also provide a grafana dashboard to get a feel for what&rsquo;s going on here (see
the <a href=../grafana/>grafana install instructions</a> first to have a working grafana
provisioned with Linkerd dashboards). You can get to it by running <code>linkerd --context=west viz dashboard</code> and going to</p><figure><img alt=grafana-dashboard class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/grafana-dashboard.png><figcaption>Grafana</figcaption></figure><h2 id=security class=anchor>Security
<a href=#security class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>By default, requests will be going across the public internet. Linkerd extends
its <a href=../../features/automatic-mtls/>automatic mTLS</a> across clusters to make sure
that the communication going across the public internet is encrypted. If you&rsquo;d
like to have a deep dive on how to validate this, check out the
<a href=../securing-your-service/>docs</a>. To quickly check, however, you can run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test viz tap deploy/frontend | <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  grep <span style=color:#a5d6ff>&#34;</span><span style=color:#ff7b72>$(</span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>east -n linkerd-multicluster get svc linkerd-gateway <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -o <span style=color:#a5d6ff>&#34;custom-columns=GATEWAY_IP:.status.loadBalancer.ingress[*].ip&#34;</span><span style=color:#ff7b72>)</span><span style=color:#a5d6ff>&#34;</span>
</span></span></code></pre></div><p><code>tls=true</code> tells you that the requests are being encrypted!</p><div class="alert alert--info alert--callout"><div class=alert__title><svg class="icon icon--current" viewBox="0 0 24 24"><path d="M13 9H11V7h2m0 10H11V11h2M12 2A10 10 0 002 12 10 10 0 0012 22 10 10 0 0022 12 10 10 0 0012 2z"/></svg><h4>Note</h4></div><div class=alert__content>As <code>linkerd viz edges</code> works on concrete resources and cannot see
two clusters at once, it is not currently able to show the edges between pods in
<code>east</code> and <code>west</code>. This is the reason we&rsquo;re using <code>tap</code> to validate mTLS here.</div></div><p>In addition to making sure all your requests are encrypted, it is important to
block arbitrary requests coming into your cluster. We do this by validating that
requests are coming from clients in the mesh. To do this validation, we rely on
a shared trust anchor between clusters. To see what happens when a client is
outside the mesh, you can run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test run -it --rm --image<span style=color:#ff7b72;font-weight:700>=</span>alpine:3 test -- <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  /bin/sh -c <span style=color:#a5d6ff>&#34;apk add curl &amp;&amp; curl -vv http://podinfo-east:9898&#34;</span>
</span></span></code></pre></div><h2 id=traffic-splitting class=anchor>Traffic Splitting
<a href=#traffic-splitting class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><figure><img alt=with-split class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/with-split.svg><figcaption>Traffic Split</figcaption></figure><p>It is pretty useful to have services automatically show up in clusters and be
able to explicitly address them, however that only covers one use case for
operating multiple clusters. Another scenario for multicluster is failover. In a
failover scenario, you don&rsquo;t have time to update the configuration. Instead, you
need to be able to leave the application alone and just change the routing. If
this sounds a lot like how we do <a href=../canary-release/>canary</a> deployments,
you&rsquo;d be correct!</p><p><code>TrafficSplit</code> allows us to define weights between multiple services and split
traffic between them. In a failover scenario, you want to do this slowly as to
make sure you don&rsquo;t overload the other cluster or trip any SLOs because of the
added latency. To get this all working with our scenario, let&rsquo;s split between
the <code>podinfo</code> service in <code>west</code> and <code>east</code>. To configure this, you&rsquo;ll run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west apply -f - <span style=color:#a5d6ff>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>apiVersion: split.smi-spec.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>kind: TrafficSplit
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>metadata:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  name: podinfo
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  namespace: test
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>spec:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  service: podinfo
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  backends:
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  - service: podinfo
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    weight: 50
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>  - service: podinfo-east
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>    weight: 50
</span></span></span><span style=display:flex><span><span style=color:#a5d6ff>EOF</span>
</span></span></code></pre></div><p>Any requests to <code>podinfo</code> will now be forwarded to the <code>podinfo-east</code> cluster
50% of the time and the local <code>podinfo</code> service the other 50%. Requests sent to
<code>podinfo-east</code> end up in the <code>east</code> cluster, so we&rsquo;ve now effectively failed
over 50% of the traffic from <code>west</code> to <code>east</code>.</p><p>If you&rsquo;re still running <code>port-forward</code>, you can send your browser to
<a href=http://localhost:8080 target=_blank rel=noopener>http://localhost:8080</a>. Refreshing the page should show
both clusters.Alternatively, for the command line approach,
<code>curl localhost:8080</code> will give you a message that greets from <code>west</code> and
<code>east</code>.</p><figure><img alt=podinfo-split class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/split-podinfo.gif><figcaption>Cross Cluster Podinfo</figcaption></figure><p>You can also watch what&rsquo;s happening with metrics. To see the source side of
things (<code>west</code>), you can run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#ff7b72;font-weight:700>=</span>west -n test viz stat trafficsplit
</span></span></code></pre></div><p>It is also possible to watch this from the target (<code>east</code>) side by running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#ff7b72;font-weight:700>=</span>east -n test viz stat <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --from deploy/linkerd-gateway <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --from-namespace linkerd-multicluster <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  deploy/podinfo
</span></span></code></pre></div><p>There&rsquo;s even a dashboard! Run <code>linkerd viz dashboard</code> and send your browser to
<a href=http://localhost:50750/namespaces/test/trafficsplits/podinfo target=_blank rel=noopener>localhost:50750</a>.</p><figure><img alt=podinfo-split class="img img--max-fill img--center img--rounded" src=/docs/images/multicluster/ts-dashboard.png><figcaption>Cross Cluster Podinfo</figcaption></figure><h2 id=cleanup class=anchor>Cleanup
<a href=#cleanup class=anchor__link><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7A5 5 0 002 12a5 5 0 005 5h4V15.1H7c-1.71.0-3.1-1.39-3.1-3.1M8 13h8V11H8v2m9-6H13V8.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1H13V17h4a5 5 0 005-5A5 5 0 0017 7z"/></svg></a></h2><p>To cleanup the multicluster control plane, you can run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd --context<span style=color:#ff7b72;font-weight:700>=</span>west multicluster unlink --cluster-name east | <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  kubectl --context<span style=color:#ff7b72;font-weight:700>=</span>west delete -f -
</span></span><span style=display:flex><span><span style=color:#ff7b72>for</span> ctx in west east; <span style=color:#ff7b72>do</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> delete ns test; <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  linkerd --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> multicluster uninstall | kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> delete -f - ; <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span><span style=color:#ff7b72>done</span>
</span></span></code></pre></div><p>If you&rsquo;d also like to remove your Linkerd installation, run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff7b72>for</span> ctx in west east; <span style=color:#ff7b72>do</span>
</span></span><span style=display:flex><span>  linkerd --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> viz uninstall | kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> delete -f -
</span></span><span style=display:flex><span>  linkerd --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> uninstall | kubectl --context<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>${</span><span style=color:#79c0ff>ctx</span><span style=color:#a5d6ff>}</span> delete -f -
</span></span><span style=display:flex><span><span style=color:#ff7b72>done</span>
</span></span></code></pre></div></div></div></div></div></div></main><footer class=main-footer><div class=main-footer__top><div class="main-footer__container container"><div class=main-footer__info><p><img src=/logos/linkerd.png alt=Linkerd></p><p>Linkerd was originally created by <a href=https://buoyant.io/ target=_blank rel=noopener>Buoyant</a></p><p>View <a href=https://github.com/linkerd/linkerd/wiki/Linkerd-code-of-conduct target=_blank rel=noopener>Code of Conduct</a></p></div><div class=main-footer__links><div class=main-footer__community><h4>Community</h4><ul><li><a href=https://github.com/linkerd/linkerd2 target=_blank rel=noopener>GitHub</a></li><li><a href=https://slack.linkerd.io target=_blank rel=noopener>Slack</a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener>Linkerd Forum</a></li></ul></div><div class=main-footer__follow><h4>Follow</h4><ul><li><a href=https://www.linkedin.com/company/linkerd/ target=_blank rel=noopener>Linkedin</a></li><li><a href=https://www.youtube.com/buoyantio target=_blank rel=noopener>YouTube</a></li><li><a href=https://twitter.com/linkerd target=_blank rel=noopener>Twitter</a></li></ul></div></div></div></div><div class=main-footer__bottom><div class="main-footer__container container"><p><a href=https://github.com/linkerd/website/tree/main/linkerd.io/content target=_blank rel=noopener>Edit This Site</a></p><p>Copyright © 2024 Linkerd Authors. All rights reserved.</p></div></div></footer></body></html>