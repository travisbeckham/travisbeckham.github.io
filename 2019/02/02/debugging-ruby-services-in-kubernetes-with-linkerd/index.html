<!doctype html><html lang=en><head><meta charset=utf-8><title>Debugging Ruby Services in Kubernetes With Linkerd | Linkerd</title>
<link rel="shortcut icon" href=/favicon.png><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Ruby continues to be one of the most popular and influential programming languages in the world. With the rise of Kubernetes, Ruby developers are increasingly being asked to deploy their services to a Kubernetes cluster. But what’s required to safely deploy and run Ruby services on Kubernetes?
In this post, we focus on one specific, but vital, component: how do I understand what’s happening with my Ruby service on Kubernetes, and how do I debug it when things go wrong?"><meta property="og:url" content="https://travisbeckham.github.io/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/"><meta property="og:site_name" content="Linkerd"><meta property="og:title" content="Debugging Ruby Services in Kubernetes With Linkerd"><meta property="og:description" content="Ruby continues to be one of the most popular and influential programming languages in the world. With the rise of Kubernetes, Ruby developers are increasingly being asked to deploy their services to a Kubernetes cluster. But what’s required to safely deploy and run Ruby services on Kubernetes?
In this post, we focus on one specific, but vital, component: how do I understand what’s happening with my Ruby service on Kubernetes, and how do I debug it when things go wrong?"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-02-02T00:00:00+00:00"><meta property="article:modified_time" content="2019-02-02T00:00:00+00:00"><meta property="og:image" content="https://travisbeckham.github.io/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/cover.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://travisbeckham.github.io/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/cover.png"><meta name=twitter:title content="Debugging Ruby Services in Kubernetes With Linkerd"><meta name=twitter:description content="Ruby continues to be one of the most popular and influential programming languages in the world. With the rise of Kubernetes, Ruby developers are increasingly being asked to deploy their services to a Kubernetes cluster. But what’s required to safely deploy and run Ruby services on Kubernetes?
In this post, we focus on one specific, but vital, component: how do I understand what’s happening with my Ruby service on Kubernetes, and how do I debug it when things go wrong?"><meta name=twitter:site content="@Linkerd"><link rel=canonical href=https://travisbeckham.github.io/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/><link rel=stylesheet href=/css/main.css><script src=/js/main.js></script><script async defer src=https://buttons.github.io/buttons.js></script><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","author":"Kevin Lingerfelt","datePublished":"2019-02-02T00:00:00Z","dateModified":"2019-02-02T00:00:00Z","headline":"Debugging Ruby Services in Kubernetes With Linkerd","image":"https://travisbeckham.github.io/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/cover.png","publisher":{"@type":"Organization","name":"linkerd.io","logo":{"@type":"ImageObject","url":"https://travisbeckham.github.io/logos/linkerd.png","width":472,"height":100}}}</script></head><body><header class=main-header><div class=main-header__container><div class=main-header__logo><a href=/><img src=/logos/linkerd.png alt=Linkerd></a></div><input class=main-header__toggle-checkbox type=checkbox id=main-header-toggle>
<label class=main-header__toggle for=main-header-toggle><span class=main-header__toggle-icon><span class=main-header__toggle-icon--open><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M3 6H21V8H3V6m0 5H21v2H3V11m0 5H21v2H3V16z"/></svg>
</span><span class=main-header__toggle-icon--close><svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg></span></span></label><div class=main-header__nav><nav class=main-nav><ul class=main-nav__menu><li><a href=/docs>Docs</a></li><li><a href>Community<svg class="icon icon--primary" viewBox="0 0 24 24"><path d="M7.41 8.58 12 13.17l4.59-4.59L18 10l-6 6-6-6L7.41 8.58z"/></svg></a><ul><li><a href=/community/get-involved/>Get Involved</a></li><li><a href=/community/adopters/>Adopters</a></li><li><a href=/community/ambassadors/>Linkerd Ambassadors</a></li><li><a href=/community/heroes/>Linkerd Heroes</a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener>Buoyant's Linkerd Forum</a></li></ul></li><li class=main-nav__menu--selected><a href=/blog/>Blog</a></li><li><a href=/faq/>FAQ</a></li><li><a href=/enterprise/>Enterprise</a></li></ul><div class=main-nav__search><form action=/search method=get><div class="search-input search-input--sm"><svg class="icon" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5.0 0116 9.5c0 1.61-.59 3.09-1.56 4.23L14.71 14H15.5l5 5L19 20.5l-5-5V14.71L13.73 14.44C12.59 15.41 11.11 16 9.5 16A6.5 6.5.0 013 9.5 6.5 6.5.0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
<input type=text name=q placeholder=Search></div></form></div><div class=main-nav__github><a class=github-button href=https://github.com/linkerd/linkerd2 data-icon=octicon-star data-size=large data-show-count=true aria-label="Star linkerd/linkerd2 on GitHub">Star</a></div><div class=main-nav__forum><a href=https://linkerd.buoyant.io class="button button--primary button--sm" target=_blank rel=noopener>Join Forum</a></div></nav></div></div></header><div class=main-announcement>Service Mesh 101: Get Service Mesh-Certified
<span class=main-announcement__link><a href=https://buoyant.io/courses/service-mesh-101 target=_blank rel=noopener>Enroll now</a></span></div><main class=main-content><div class="blog blog--single"><div class="blog__container container"><div class=blog-post><div class=blog-post__header><h1>Debugging Ruby Services in Kubernetes With Linkerd</h1><div class=blog-post-meta><div class=blog-post-meta__body><div class=blog-post-meta__name>Kevin Lingerfelt</div><div class=blog-post-meta__date>Feb 2, 2019 • 9 min read</div></div></div></div><div class=blog-post__cover></div><div class="blog-post__content prose"><p>Ruby continues to be one of the most popular and influential programming languages in the world. With the rise of Kubernetes, Ruby developers are increasingly being asked to deploy their services to a Kubernetes cluster. But what’s required to safely deploy and run Ruby services on Kubernetes?</p><p>In this post, we focus on one specific, but vital, component: how do I understand what’s happening with my Ruby service on Kubernetes, and how do I debug it when things go wrong?</p><p>One of the advantages of Kubernetes is that it is able to handle certain types of failures automatically. Kubernetes can automatically keep your service up in the event of node failure or a software crash. However, Kubernetes doesn’t actually know whether your service is behaving <em>correctly.</em> A service that’s returning 500’s or taking too long to respond will still be considered healthy by Kubernetes.</p><p>This is why Kubernetes is often used in conjunction with something like Linkerd. Linkerd is a <em>service mesh</em> that augments any Kubernetes service, providing zero-config “golden metrics” dashboards and UNIX-style CLI tools for runtime debugging, diagnostics, and reliability. Linkerd works by inserting an ultralight proxy (&lt;10mb) into each pod of service, and automatically sending traffic to and from that pod through its proxy. These proxies provide telemetry data to, and receive signals from, a control plane. Because the proxy runs alongside your application and is transparent, there are zero code changes required. And, of course, Linkerd is completely open source, Apache v2 licensed and is hosted by the Cloud Native Computing Foundation–just like Kubernetes itself.</p><p>In this tutorial, we’ll walk you through deploying Linkerd on a Kubernetes cluster and using it to debug failures in an example Ruby application.</p><h2 id=the-books-app>The Books App</h2><p>The Books app, as you might imagine, is a Ruby application that helps you manage your bookshelf. It’s written as microservices and uses JSON over HTTP to communicate with the other services in the app. It’s composed of the following three services:</p><ul><li><a href=https://github.com/BuoyantIO/booksapp/blob/master/webapp.rb target=_blank rel=noopener>webapp</a>: the frontend</li><li><a href=https://github.com/BuoyantIO/booksapp/blob/master/authors.rb target=_blank rel=noopener>authors</a>: an API to manage the authors in the system</li><li><a href=https://github.com/BuoyantIO/booksapp/blob/master/books.rb target=_blank rel=noopener>books</a>: an API to manage the books in the system</li></ul><p>For demo purposes, the app comes with a simple traffic generator. The overall topology looks like this: The overall topology looks like this:</p><figure><img alt="overall topology" class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/topology.png><figcaption>Topology</figcaption></figure><h2 id=prerequisites>Prerequisites</h2><p>Before you begin this guide, you&rsquo;ll need the following:</p><ul><li>Kubernetes cluster - If you don’t have a Kubernetes cluster, don’t worry! Take a look at <a href=https://github.com/kubernetes/minikube target=_blank rel=noopener>minikube</a>, or at the <a href=https://kubernetes.io/docs/setup/ target=_blank rel=noopener>Kubernetes documentation</a>.</li></ul><h2 id=step-1--install-the-demo-app->Step 1 — Install the demo app 🚀</h2><p>Before we install Linkerd, let’s add the books app onto your cluster. In your local terminal, just run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create ns booksapp <span style=color:#ff7b72;font-weight:700>&amp;&amp;</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  curl --proto <span style=color:#a5d6ff>&#39;=https&#39;</span> --tlsv1.2 -sSfL https://run.linkerd.io/booksapp.yml | <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  kubectl -n booksapp apply -f -
</span></span></code></pre></div><p>This command creates a namespace for the demo, downloads its Kubernetes manifest and uses <em>kubectl</em> to apply it to your Kubernetes cluster. The app is comprised of several services that run in the booksapp namespace.</p><p>Downloading a bunch of containers and starting mysql up for the first time takes a little while. Kubernetes can tell you when all the services are running and ready for traffic. Wait for that to happen by running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl -n booksapp rollout status deploy webapp
</span></span></code></pre></div><p>You can also take a quick look at all the components that were added to your cluster by running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl -n booksapp get all
</span></span></code></pre></div><p>Once the rollout has completed successfully, you can forward the <a href=http://localhost:7000/ target=_blank rel=noopener>frontend</a> (webapp) locally for viewing <a href=http://localhost:7000 target=_blank rel=noopener>http://localhost:7000</a> by running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl -n booksapp port-forward <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  <span style=color:#ff7b72>$(</span>kubectl -n booksapp get po -l <span style=color:#79c0ff>app</span><span style=color:#ff7b72;font-weight:700>=</span>webapp <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    -o <span style=color:#79c0ff>jsonpath</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#39;{.items[0].metadata.name}&#39;</span><span style=color:#ff7b72>)</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  7000:7000 &amp;
</span></span></code></pre></div><figure><img alt="books app overview" class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/books.png><figcaption>books app overview</figcaption></figure><p>As you can imagine, there is an error in the app. If you click Add Book, it will fail 50% of the time. This is a classic case of non-obvious, intermittent failure - the type that drives service owners mad because it is so difficult to debug. Because Kubernetes is interested in keeping processes running, it will show you that everything is running. It looks like everything’s fine, but you know the application is returning errors.</p><figure><img alt=errors class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/errors.png><figcaption>errors</figcaption></figure><p>In the next few steps, we’ll walk you through how to use Linkerd to diagnose the problem.</p><h2 id=step-2--install-linkerds-cli>Step 2 — Install Linkerd’s CLI</h2><p>We’ll start by installing Linkerd’s command-line interface (CLI) onto your local machine. Visit the Linkerd releases page, or simply run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl --proto <span style=color:#a5d6ff>&#39;=https&#39;</span> --tlsv1.2 -sSfL https://run.linkerd.io/install | sh
</span></span></code></pre></div><p>Once installed, add the linkerd command to your path with:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>export <span style=color:#79c0ff>PATH</span><span style=color:#ff7b72;font-weight:700>=</span><span style=color:#79c0ff>$PATH</span>:<span style=color:#79c0ff>$HOME</span>/.linkerd2/bin
</span></span></code></pre></div><p>Let’s validate that your cluster is prepared for Linkerd by running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd check --pre
</span></span></code></pre></div><p>As there are many different types of Kubernetes clusters, and an infinite set of ways to configure them, this handy command will report any problems that would interfere with your ability to install Linkerd. Hopefully, everything looks OK and you’re ready to move on to the next step.</p><p>As there are many different types of Kubernetes clusters, and an infinite set of ways to configure them, this handy command will report any problems that would interfere with your ability to install Linkerd. Hopefully, everything looks OK and you’re ready to move on to the next step.</p><p>Note: if your Kubernetes cluster is on GKE with RBAC enabled, you’ll need an extra step: you must grant a ClusterRole of cluster-admin to your Google Cloud account first, in order to install the control plane. To do that, run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create clusterrolebinding cluster-admin-binding-<span style=color:#79c0ff>$USER</span> <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --clusterrole cluster-admin <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  --user<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#ff7b72>$(</span>gcloud config get-value account<span style=color:#ff7b72>)</span>
</span></span></code></pre></div><h3 id=step-3--install-linkerds-control-plane-onto-the-cluster>Step 3 — Install Linkerd’s control plane onto the cluster</h3><p>In this step, we’ll install Linkerd’s lightweight control plane into its own namespace (<code>linkerd</code>) on your cluster. To do this, run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd install | kubectl apply -f –
</span></span></code></pre></div><p>This command generates a Kubernetes manifest and uses kubectl to apply it to your Kubernetes cluster. (Feel free to read the full manifest before you apply it.)</p><p>Depending on the speed of your connection, it might take a minute for your Kubernetes cluster to pull down the Linkerd container images and get them started. While that’s happening, you can validate that everything’s installing correctly by running:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd check
</span></span></code></pre></div><p>This command will wait until Linkerd has been installed and is running. Now, let’s check out Linkerd’s dashboard! Just run:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>linkerd dashboard
</span></span></code></pre></div><p>If you see something similar to the screenshot below, Linkerd is now running on your cluster. 🎉</p><figure><img alt="linkerd running on the cluster" class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/linkerd.png><figcaption>linkerd running on the cluster</figcaption></figure><h2 id=step-4--add-linkerd-to-the-webapp-service>Step 4 — Add Linkerd to the webapp service</h2><p>At this point, we have the Linkerd control plane installed in the linkerd namespace, and we have our demo app installed in the booksapp namespace. We now need to add Linkerd to our service. In this example, let’s pretend we are the owners of the webapp service. Let’s just say that other services, like authors and books, are owned by other teams &ndash; we don’t want to touch them. While these are local services in this example, it is entirely possible that they could be remote APIs owned by a completely separate entity. There are a couple of ways to add Linkerd to our service. For demo purposes, the easiest is to do something like this:</p><div class=highlight><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get -n booksapp deploy/webapp -o yaml <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  | linkerd inject - <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>  | kubectl apply -f -
</span></span></code></pre></div><p>This command retrieves the manifest of the webapp service from Kubernetes, runs this manifest through linkerd inject, and then re-applies it to the Kubernetes cluster. The linkerd inject command adds to the manifest to include the data plane’s proxies. As with install, inject is a pure text operation. This means that you can inspect the input and output before you use it. Since webapp is a Deployment, Kubernetes is kind enough to slowly roll the service one pod at a time–meaning that webapp can be serving traffic live while we add Linkerd to it!</p><p>We now have a service mesh running on the webapp service!</p><h2 id=step-5--debugging-your-ruby-service>Step 5 — Debugging Your Ruby Service</h2><p>Cool! You have a full Ruby application running on your Kubernetes cluster with Linkerd installed on the webapp service. Let’s use Linkerd to discover the root cause in minutes without any code changes. Check out the Linkerd dashboard (the linkerd dashboard command). You should see all the services in the booksapp namespace show up. Since webapp has the Linkerd sidecar installed on it, you’ll also see success rate, requests per second, and latency percentiles.</p><figure><img alt=overview class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/overview.png><figcaption>overview</figcaption></figure><p>That’s cool, but you’ll notice that the success rate for webapp is not 100%. This is because the traffic generator is submitting new books. You can do the same thing yourself and push that success rate even lower. Click on webapp in the Linkerd dashboard for a live debugging session.</p><p>You should now be looking at the detail view for the webapp service. You’ll see that webapp is taking traffic from traffic, and has two outgoing dependencies: authors and book. One is the service for pulling in author information and the other is the service for pulling in book information.</p><figure><img alt="detail view of webapp service" class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/detail.png><figcaption>detail view of webapp service</figcaption></figure><p>A failure in a dependent service may be exactly what’s causing the errors that webapp is returning (and the errors you as a user can see when you click). We can see that books service is also failing. Let’s scroll a little further down the page, we’ll see a live list of all traffic endpoints that webapp is receiving. This is interesting:</p><figure><img alt="list of traffic endpoints" class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/endpoints.png><figcaption>list of traffic endpoints</figcaption></figure><p>Aha! We can see that inbound traffic coming from the webapp service going to the books service is failing a significant percentage of the time. That could explain why webapp was throwing intermittent failures. Let’s click on the 🔬 icon to look at the actual request and response stream.</p><figure><img alt="request details" class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/request.png><figcaption>request details</figcaption></figure><p>Indeed, many of these requests are returning 500&rsquo;s.</p><p>It was surprisingly easy to diagnose an intermittent issue that affected only a single route. Assuming that someone else operates the books service, you now have everything you need to open a detailed bug report explaining exactly what the root cause is. If the books service was your own, you know exactly where to look in the code.</p><h2 id=conclusion>Conclusion</h2><p>In this tutorial, we’ve shown you how to install Linkerd on a cluster, add it as a service mesh to just one service–while the service is receiving live traffic! — and use it to debug a runtime issue. But this is just the tip of the iceberg.</p><p>For example, everything we did above using the web UI can also be accomplished via pure CLI commands, e.g. linkerd top, linkerd stat, and linkerd tap.</p><p>Also, did you notice the little Grafana icon on the very first page we looked at? Linkerd ships with automatic Grafana dashboards for all those metrics, allowing you to view everything you’re seeing in the Linkerd dashboard in a time series format. Check it out!</p><figure><img alt="linkerd deployment" class="img img--max-fill img--center img--rounded" src=/2019/02/02/debugging-ruby-services-in-kubernetes-with-linkerd/deployment.png><figcaption>linkerd deployment</figcaption></figure><p>Linkerd has a thriving community of adopters and contributors, and we’d love for YOU to be a part of it. For more, check out the <a href=https://linkerd.io/docs target=_blank rel=noopener>docs</a> and <a href=https://github.com/linkerd/linkerd target=_blank rel=noopener>GitHub</a> repo, join the <a href=https://slack.linkerd.io/ target=_blank rel=noopener>Linkerd Slack,</a> mailing lists (<a href=https://lists.cncf.io/g/cncf-linkerd-users target=_blank rel=noopener>users</a>, <a href=https://lists.cncf.io/g/cncf-linkerd-dev target=_blank rel=noopener>developers</a>, <a href=https://lists.cncf.io/g/cncf-linkerd-announce target=_blank rel=noopener>announce</a>), and San Francisco <a href=https://www.meetup.com/San-Francisco-Linkerd-Meetup/ target=_blank rel=noopener>Linkerd Meetup</a>, and, of course, follow <a href=https://twitter.com/linkerd target=_blank rel=noopener>@linkerd</a> on Twitter! We can’t wait to have you aboard!</p></div></div><div class=blog-post-related><h2>Suggested Blog Posts</h2><div class=blog-post-related__pages><div class="card card--horz card--center"><div class=card__media><img src=/2018/12/08/service-profiles-for-per-route-metrics/cover.png alt=Cover class="img img--128 img--rounded"></div><div class=card__body><div class=card__header><h4><a href=/2018/12/08/service-profiles-for-per-route-metrics/>Service Profiles for Per-Route Metrics</a></h4><div class=blog-post-meta><div class=blog-post-meta__date>Dec 8, 2018 • 7 min read</div></div></div></div></div><div class="card card--horz card--center"><div class=card__media><img src=/2018/11/14/grpc-load-balancing-on-kubernetes-without-tears/cover.png alt=Cover class="img img--128 img--rounded"></div><div class=card__body><div class=card__header><h4><a href=/2018/11/14/grpc-load-balancing-on-kubernetes-without-tears/>gRPC Load Balancing on Kubernetes without Tears</a></h4><div class=blog-post-meta><div class=blog-post-meta__date>Nov 14, 2018 • 6 min read</div></div></div></div></div><div class="card card--horz card--center"><div class=card__media><img src=/2018/11/13/debugging-node-services-in-kubernetes-with-linkerd-2.0/cover.png alt=Cover class="img img--128 img--rounded"></div><div class=card__body><div class=card__header><h4><a href=/2018/11/13/debugging-node-services-in-kubernetes-with-linkerd-2.0/>Debugging Node Services in Kubernetes With Linkerd 2.0</a></h4><div class=blog-post-meta><div class=blog-post-meta__date>Nov 13, 2018 • 9 min read</div></div></div></div></div></div></div></div></div></main><footer class=main-footer><div class=main-footer__top><div class="main-footer__container container"><div class=main-footer__info><p><img src=/logos/linkerd.png alt=Linkerd></p><p>Linkerd was originally created by <a href=https://buoyant.io/ target=_blank rel=noopener>Buoyant</a></p><p>View <a href=https://github.com/linkerd/linkerd/wiki/Linkerd-code-of-conduct target=_blank rel=noopener>Code of Conduct</a></p></div><div class=main-footer__links><div class=main-footer__community><h4>Community</h4><ul><li><a href=https://github.com/linkerd/linkerd2 target=_blank rel=noopener>GitHub</a></li><li><a href=https://slack.linkerd.io target=_blank rel=noopener>Slack</a></li><li><a href=https://linkerd.buoyant.io target=_blank rel=noopener>Linkerd Forum</a></li></ul></div><div class=main-footer__follow><h4>Follow</h4><ul><li><a href=https://www.linkedin.com/company/linkerd/ target=_blank rel=noopener>Linkedin</a></li><li><a href=https://www.youtube.com/buoyantio target=_blank rel=noopener>YouTube</a></li><li><a href=https://twitter.com/linkerd target=_blank rel=noopener>Twitter</a></li></ul></div></div></div></div><div class=main-footer__bottom><div class="main-footer__container container"><p><a href=https://github.com/linkerd/website/tree/main/linkerd.io/content target=_blank rel=noopener>Edit This Site</a></p><p>Copyright © 2024 Linkerd Authors. All rights reserved.</p></div></div></footer></body></html>